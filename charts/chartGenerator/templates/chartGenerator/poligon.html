<head>
    <!-- divine meta data of the page -->
    <meta http-equiv="content-type" content="text/html" charset="UTF-8">




    
    <!-- import the fitCanvasToDiv.js file -->
    <script>function
    fitCanvas() {
    var offsetButtons = 25;
    var canvasSpec = document.getElementById("canvasSpec")
    var canvasSpecLine = document.getElementById("canvasSpecLine")
    var canvasSpecScale = document.getElementById('canvasSpecScale');
    var divSpec = document.getElementById("canvasDivSpec")
    var divWave = document.getElementById("canvasDivWave")
    var canvasWave = document.getElementById("canvasWave");
    var canvasWaveLine = document.getElementById("canvasWaveLine");
    var canvasRMS = document.getElementById("canvasRMS");
    var canvasSelect = document.getElementById("canvasSelect");
    var canvasWaveScale = document.getElementById("canvasWaveScale");
    var canvasWaveGrid = document.getElementById("canvasWaveGrid");


    var divSpecWidth = divSpec.offsetWidth-offsetButtons;
    var divWaveWidth = divWave.offsetWidth-3-offsetButtons;


    canvasSpec.width = divSpecWidth - SpectroData.scaleOfsetLeft;
    canvasSpecLine.width = divSpecWidth - SpectroData.scaleOfsetLeft;
    canvasSpecScale.width = divSpecWidth;
    canvasWave.width = divWaveWidth - offSetLeft - 20;
    canvasWaveLine.width = divWaveWidth - offSetLeft - 20;
    canvasRMS.width = divWaveWidth - offSetLeft - 20;
    canvasSelect.width = divWaveWidth - offSetLeft - 20;
    canvasWaveScale.width = divWaveWidth;
    canvasWaveGrid.width = divWaveWidth - offSetLeft - 20;

}

function resizeCanvas() {
    var offsetButtons = 25;
    var canvasSpec = document.getElementById("canvasSpec")
    var canvasSpecLine = document.getElementById("canvasSpecLine")
    var canvasSpecScale = document.getElementById('canvasSpecScale');
    var ctx = canvasSpec.getContext('2d')
    var divSpec = document.getElementById("canvasDivSpec")
    var divWave = document.getElementById("canvasDivWave")
    var canvasWave = document.getElementById("canvasWave");
    var ctxWave = canvasWave.getContext('2d')
    var canvasWaveLine = document.getElementById("canvasWaveLine");
    var canvasRMS = document.getElementById("canvasRMS");
    var ctxRMS = canvasRMS.getContext('2d')
    var canvasSelect = document.getElementById("canvasSelect");
    var canvasWaveScale = document.getElementById("canvasWaveScale");
    var canvasWaveGrid = document.getElementById("canvasWaveGrid");

    var divSpecWidth = divSpec.offsetWidth - offsetButtons;
    var divWaveWidth = divWave.offsetWidth - offsetButtons;

    if (canvasSpec.width <= divSpecWidth) {
        canvasSpec.width = divSpecWidth - SpectroData.scaleOfsetLeft;
        canvasSpecLine.width = divSpecWidth - SpectroData.scaleOfsetLeft;
        canvasSpecScale.width = divSpecWidth - 3;
        if (typeof(viridisScale) != "undefined") {
            ctx.scale(canvasSpec.width / SpectroData.specWidth, canvasSpec.height / SpectroData.specHight);
            SpectroData.scaleFactorWidth = canvasSpec.width / SpectroData.specWidth;
            ctx.clearRect(0, 0, canvasSpec.width, canvasSpec.height);
            ctx.drawImage(tempCanvas, 0, 0);
            drawScale()
            section = getSectionDisplayed()
            drawSelection(section.min, 2, section.max);
        }
    }

    canvasWave.width = divWaveWidth - offSetLeft;
    canvasWaveLine.width = divWaveWidth - offSetLeft;
    canvasRMS.width = divWaveWidth - offSetLeft;
    canvasSelect.width = divWaveWidth - offSetLeft;
    canvasWaveScale.width = divWaveWidth;
    canvasWaveGrid.width = divWaveWidth - offSetLeft;
    if (typeof(viridisScale) != "undefined") {
        ctxRMS.setTransform(1, 0, 0, 1, 0, 0);
        ctxWave.setTransform(1, 0, 0, 1, 0, 0);
        ctxRMS.clearRect(0, 0, canvasWave.width, canvasWave.height);
        ctxWave.clearRect(0, 0, canvasWave.width, canvasWave.height);
        ctxRMS.scale(canvasWave.width / tempWaveCanvas.width, canvasWave.height / tempWaveCanvas.height);
        ctxWave.scale(canvasWave.width / tempWaveCanvas.width, canvasWave.height / tempWaveCanvas.height);
        WaveData.scaleX = canvasWave.width / tempWaveCanvas.width
        ctxRMS.drawImage(tempRMSCanvas, 0, 0);
        ctxWave.drawImage(tempWaveCanvas, 0, 0);
        drawWaveTimeAxes()
        drawWaveGrid();
        section = getSectionDisplayed()
        drawSelection(section.min, 2, section.max);
    }
}</script>

    <!-- set tab title of the website -->
    <title>Audioanalyzer</title>

    <!-- link to the masters.css stylesheet -->
    <link rel="stylesheet" type="text/css" href="css/master.css">

    <!-- import image for tab icon -->
    <link rel="icon" type="image/png" href="image/icon.png">
</head>

<body onload="fitCanvas()" onresize="resizeCanvas()">

    <!-- set image and link to github repo -->
    <a href="https://github.com/saschabilert/audioanalyzer" target="_blank">
        <img class="githubribbon" id="githubribbonmain" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67"
            alt="Fork us on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png">
    </a>

    <!-- Create the header -->
    <header>
        <h1>Audioanalyzer</h1>
        <a href="index.html" class="link">
            <li class="currentpage">Analyzer</li>
        </a>
        <a href="instructions.html" class="link" target="_blank">Instructions</a>
        <a href="about.html" class="link" target="_blank">About</a>
    </header>

    <!--Create the loading animation-->
    <div id="container" style="display:none;"></div>
    <img id="loading" class="rotating" src="image/icon.png" height="300px" width="300px" style="display: none">

    <!-- Create a div with all the buttons above the waveform -->
    <div id="buttonsMenu">
        <form method="post" enctype="multipart/form-data" action="">
            <!-- set input audiofile and trigger the audioProcessing function -->
            <input type="file" class="audioInput" id="myAudio" name="myAudio[]" accept="audio/*" onchange="loadAudio()">
            <label for="myAudio">Choose a file</label>
        </form>
        <div class="buttons">
            <button id="player" type="button" class="playPause" disabled>&#9654;</button>
            <button id="stop" type="button" class="stop" disabled>&#9724;</button>
            <div class="range-container"><input id="volume" type="range" min="0" max="1" step="0.1" value="0.5" class="Gain" disabled><span class="tooltiptext">Adjust the volume
                                         by dragging the bar</span></div>
        </div>
        <div id="playbackTime">00:00.0&thinsp;/&thinsp;00:00.0</div>
        <div class="range-container">
            <div id="loopText">Loop Selection<input type="checkbox" id="LoopCheck" onchange="setLoop(this)" disabled></div><span class="tooltiptext">Tick to loop a selected part of the audiofile</span></div>
        <div id="gridSize">Grid Size:
            <div class="range-container"><select id="grid" onchange="gridSize()" disabled>
        <option value="0.0625">small</option>
        <option value="0.125">medium</option>
        <option value="0.25">large</option>
      </select>
                <span class="tooltiptext">Select the grid size of the waveform</span></div>
        </div>
    </div>

    <!-- Create a canvas with the waveform -->
    <div class="canvas" id="canvasDivWave">
        <canvas id="canvasWaveScale" width="1200" height="280"></canvas>
        <canvas id="canvasWaveGrid" width="1176" height="260"></canvas>
        <canvas id="canvasWave" width="1176" height="260"></canvas>
        <canvas id="canvasRMS" width="1176" height="260"></canvas>
        <canvas id="canvasSelect" width="1176" height="260"></canvas>
        <canvas id="canvasWaveLine" width="1176" height="260"></canvas>
        <div id="divWavePosition">
            <p id="waveTime">Time: </p>
            <p id="amplitudeValue">Amplitude: </p>
            <p id="rmsValue">RMS: </p>
        </div>
    </div>

    <!-- Create the dropdown menu with all settings -->
    <div class="dropdownContainer">
        <div class="dropdownBlock">
            <p>Block-Length:</p>
            <div class="range-container">
                <select id="blockLength" onchange="blockLength()">
                        <option value="512">512</option>
                        <option value="1024" selected>1024</option>
                        <option value="2048">2048</option>
                        <option value="4096">4096</option>
                        <option value="8192">8192</option>
                  </select>
                <span class="tooltiptext">Increasing the block size, will increase the frequency resolution</span>
            </div>
        </div>
        <div class="dropdownBlock">
            <p>Window-Type:</p>
            <div class="range-container">
                <select id="windowType" onchange="windowType()">
                     <option value="hann" selected>hann</option>
                     <option value="rect">rectangle</option>
                     <option value="hannpoisson">hann-poisson</option>
                     <option value="cosine">cosine</option>
                     <option value="flat-top">flat-top</option>
                     <option value="hamming">hamming</option>
                     <option value="blackman">blackman</option>
               </select>
                <span class="tooltiptext">Different window types in relation between smiring and selectivity</span>
            </div>
        </div>
        <div class="dropdownBlock">
            <p>Overlap:</p>
            <div class="range-container">
                <select id="overlap" onchange="overlap()">
                        <option value="0.0">0%</option>
                        <option value="0.25">25%</option>
                        <option value="0.5" selected>50%</option>
                        <option value="0.75">75%</option>
                        <option value="0.9">90%</option>
                  </select>
                <span class="tooltiptext">Using more overlap provides more time locality resolution as well as more informational redundancy. </span>
            </div>
        </div>
        <div class="dropdownBlock">
            <p>Display-Type:</p>
            <div class="range-container">
                <select id="display" onchange="chooseDisplay()">
                        <option value="Spectrum" selected>spectrum</option>
                        <option value="Phase">phase</option>
                        <option value="Group Delay">group delay</option>
                        <option value="Instantaneous Frequency Deviation">instantaneous frequency deviation</option>
                  </select>
                <span class="tooltiptext">The display types show different information</span>
            </div>
        </div>
        <div class="dropdownBlock">
            <p>Colormap:</p>
            <div class="range-container">
                <select id="colormap" onchange="colormap()">
                        <option value="1" selected>viridis</option>
                        <option value="2">gray</option>
                        <option value="3">jet</option>
                        <option value="4">plasma</option>
                        <option value="5" disabled>twilight</option>
                        <option value="6" disabled>sunlight</option>
                   </select>
                <span class="tooltiptext">Select the colormap for the Spectrogram</span>
            </div>
        </div>
        <div class="dropdownBlock">
            <p>Value Range</p>
            <div class="range-container">
                <input type="text" id="min" onkeypress="minMaxValue(event)" placeholder="min:">
                <input type="text" id="max" onkeypress="minMaxValue(event)" placeholder="max">
                <span class="tooltiptext">Select min and max value of the range the colormap is applyed on</span>
            </div>
        </div>
        <div class="canvas" id="divCanvasLegend">
            <canvas id="canvasLegend" width="300" height="75"></canvas>
        </div>
    </div>

    <!-- import javascript files -->
    <script>
        function gridSize() {
    WaveData.gridScale = +(document.getElementById("grid").value);
    drawWaveGrid();
}

// get the user choice of block length
function blockLength() {
    Audiodata.blockLen = +(document.getElementById("blockLength").value);
    processAudio();
}

// get the user choice of window type
function windowType() {
    Audiodata.windowFunction = document.getElementById("windowType").value;
    processAudio();
}

// get the user choice of overlap
function overlap() {
    Audiodata.overlap = +(document.getElementById("overlap").value);
    processAudio();
}

// get the user choice of display type
function chooseDisplay() {
    Audiodata.display = document.getElementById("display").value;
    processAudio();
    // if this three display types are chosen, disable the colormap and the min and max values and set the right colormap
    if (Audiodata.display == "Phase" || Audiodata.display == "Instantaneous Frequency Deviation" || Audiodata.display == "Group Delay") {
        document.getElementById("colormap").value = "5";
        document.getElementById("colormap").disabled = true;
        document.getElementById("min").disabled = true;
        document.getElementById("max").disabled = true;
        document.getElementById("saveSpec").disabled = true;
        if (Audiodata.display == "Instantaneous Frequency Deviation") {
            document.getElementById("colormap").value = "6";
        }
    } else {
        document.getElementById("colormap").value = "1";
        document.getElementById("colormap").disabled = false;
        document.getElementById("min").disabled = false;
        document.getElementById("max").disabled = false;
    }
}

// get the user choice of colormap
function colormap() {
    SpectroData.TypeColorScale = +(document.getElementById("colormap").value);
    draw();
}

// define the needed global variables for audio signal
var startOffset = 0;
var startTime = 0;
var audPlay;
var isPlaying = false;
var gainNode;
var durationTrack;

// get the user input for play or pause the signal
var playButton = document.getElementById("player");
playButton.addEventListener("click", toggleSound);

// get the user input for stopping the signal
var stopButton = document.getElementById("stop");
var info = document.getElementById("playbackTime");

// save the current gain
document.getElementById('volume').addEventListener('input', function() {
    gainNode.gain.value = this.value;
});

// if user presses "Space", play/pause the file
document.onkeydown = function(e) {
    var keyCode = e.keyCode;
    if (keyCode == 32) {
        toggleSound();
        e.preventDefault();
    }
};

// play, pause and stop the signal
function toggleSound() {
    if (!isPlaying) {
        startTime = audioCtx.currentTime;
        audPlay = audioCtx.createBufferSource();
        audPlay.buffer = myArrayBuffer;
        audPlay.start(0, startOffset);
        playButton.innerHTML = "&#10074;&#10074;";
        isPlaying = true;
        window.requestAnimationFrame(drawLinePlay);
        window.requestAnimationFrame(drawLinePlayWave);
        timeUpdate();
    } else {
        audPlay.stop();
        isPlaying = false;
        playButton.innerHTML = "&#9654;";
        startOffset += audioCtx.currentTime - startTime;
    }
    gainNode = audioCtx.createGain();
    audPlay.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    gainNode.gain.value = document.getElementById('volume').value
}

// show song name after importing it
var inputs = document.querySelectorAll('.audioInput');
Array.prototype.forEach.call(inputs, function(input) {

    var label = input.nextElementSibling;

    input.addEventListener('change', function(e) {

        var fileName = e.target.value.split('\\').pop();
        label.innerHTML = fileName;
        if (fileName === "") {
            fileName = "Choose a file";
            label.innerHTML = fileName;
            document.getElementById("loading").style.display = "none";
            document.getElementById("container").style.display = "none";
        }
    });
});

// function for enabling the buttons after loading a file
function enableButton() {
    playButton.disabled = false;
    stopButton.disabled = false;
    document.getElementById("grid").disabled = false;
    document.getElementById("saveSpec").disabled = false;
    document.getElementById("LoopCheck").disabled = false;
    document.getElementById("volume").disabled = false;
    document.getElementById("saveSpec").disabled = false;
}

// values for displaying the spectrum
function minMaxValue(e) {

    var min = 0;
    var max = 0;
    if (e.keyCode == 13 || e.which == 13) {

        min = document.getElementById("min").value;
        max = document.getElementById("max").value;
        if (min !== 0) {
            min = parseInt(min);
        } else {
            min = 1;
        }
        if (max !== 0) {
            max = parseInt(max);
        } else {
            max = 1;
        }

        if (min < 0 && max < 0 && max > min) {
            SpectroData.specLevelHigh = max;
            SpectroData.specLevelLow = min;
            SpectroData.specLevelWidth = Math.abs(SpectroData.specLevelHigh - SpectroData.specLevelLow);
            document.getElementById("min").value= []
            document.getElementById("max").value= []
            document.getElementById("min").placeholder= "min: " + min
            document.getElementById("max").placeholder="max: " + max
        } else if (min < 0 && isNaN(max) && SpectroData.specLevelHigh > min) {

            SpectroData.specLevelLow = min;
            SpectroData.specLevelWidth = Math.abs(SpectroData.specLevelHigh - SpectroData.specLevelLow);
            document.getElementById("min").value= []
            document.getElementById("min").placeholder= "min: " + min
        } else if (isNaN(min) && max < 0 && SpectroData.specLevelLow < max) {

            SpectroData.specLevelHigh = max;
            SpectroData.specLevelWidth = Math.abs(SpectroData.specLevelHigh - SpectroData.specLevelLow);
            document.getElementById("max").value= []
            document.getElementById("max").placeholder="max: " + max
        } else if (min >= 0 || max >= 0 || max < min) {
            alert("Es duerfen nur Werte <= -1 eingetragen werden. Ausserdem muss min Value kleiner sein als max Value ");
        }
        draw();
    }
}

// function to calculate the time in minutes, seconds and miliseconds
function timeToString(time, alwaysShowFull, stepSize) {
    if (time == 0) {

        return "0"
    }
    var minutes = Math.floor((time) / 60);
    var seconds = Math.floor((time) - minutes * 60);
    var miliseconds = Math.floor((time % 1) * 10);

    var modoStepSize = stepSize % 1

    if (seconds < 10) {
        seconds = "0" + seconds;
    }
    if (minutes < 10) {
        minutes = "0" + minutes;
    }
    if (alwaysShowFull == 1) {
        if (time < 0) {
            return "00:00.0"
        }
        return [minutes + ":" + seconds + "." + miliseconds];
    } else if (alwaysShowFull == 0) {
        if ((minutes == "00") && (Audiodata.signalLen / Audiodata.sampleRate) < 60) {
            if (miliseconds != 0 || modoStepSize != 0) {
                return [seconds + "." + miliseconds];
            } else {
                return [seconds];
            }
        } else {
            if (modoStepSize != 0) {
                return [minutes + ":" + seconds + "." + miliseconds];
            } else {
                if (miliseconds != 0) {
                    return [minutes + ":" + seconds + "." + miliseconds];
                } else {
                    return [minutes + ":" + seconds];
                }
            }
        }
    }
}

// function to update the playback time
function timeUpdate() {
    window.requestAnimationFrame(timeUpdate);
    if (isPlaying === false) {
        return
    }

    var currentTime = (audioCtx.currentTime - startTime + startOffset);

    var durationTrack = (Audiodata.signalLen / Audiodata.sampleRate);

    info.innerHTML = timeToString(currentTime, 1, 0) + "&thinsp;/&thinsp;" + timeToString(durationTrack, 1, 0);

    if ((audioCtx.currentTime - startTime + startOffset) > Audiodata.signalLen / Audiodata.sampleRate) {
        audioCtx.currentTime = 0;
        startTime = 0;
        startOffset = 0;

        isPlaying = false;
        info.innerHTML = "00:00.0" +
            "&thinsp;/&thinsp;" + timeToString(durationTrack, 1, 0);

        drawLineKlick(0);
        drawLineKlickWave(0);
    } else if (((audioCtx.currentTime - startTime + startOffset) >= SpectroData.endTimeSelection)) {
        audioCtx.currentTime = 0;

        isPlaying = false;
        info.innerHTML = timeToString(currentTime, 1, 0) + "&thinsp;/&thinsp;" + timeToString(durationTrack, 1, 0);
        audPlay.stop();
        if (loopSelection) {
            toggleSound();
        }
    }
    stopButton.onclick = function() {
        startTime = 0;
        startOffset = 0;
        isPlaying = false;
        audPlay.stop();
        info.innerHTML = "00:00.0" +
            "&thinsp;/&thinsp;" + timeToString(durationTrack, 1, 0);
        drawLineKlick(0);
        drawLineKlickWave(0);
    };
    audPlay.onended = function() {
        playButton.innerHTML = "&#9654;";
        if ((audioCtx.currentTime - startTime + startOffset) > Audiodata.signalLen / Audiodata.sampleRate) {
            startTime = 0;
            startOffset = 0;
            isPlaying = false;
            info.innerHTML = "00:00.0" +
                "&thinsp;/&thinsp;" + timeToString(durationTrack, 1, 0);
        }
    };
}

// check the loop selection
var loopSelection = false;

function setLoop() {
    loopSelection = document.getElementById("LoopCheck").checked;
}
</script>
    <script>"use strict";

/*
 * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.
 * The vector can have any length. This is a wrapper function.
 */
function transform(real, imag) {
    if (real.length != imag.length)
        throw "Mismatched lengths";

    var n = real.length;
    if (n == 0)
        return;
    else if ((n & (n - 1)) == 0) // Is power of 2
        transformRadix2(real, imag);
    else // More complicated algorithm for arbitrary sizes
        transformBluestein(real, imag);
    }

/*
 * Computes the inverse discrete Fourier transform (IDFT) of the given complex vector, storing the result back into the vector.
 * The vector can have any length. This is a wrapper function. This transform does not perform scaling, so the inverse is not a true inverse.
 */
function inverseTransform(real, imag) {
    transform(imag, real);
}

/*
 * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.
 * The vector's length must be a power of 2. Uses the Cooley-Tukey decimation-in-time radix-2 algorithm.
 */
function transformRadix2(real, imag) {
    // Initialization
    if (real.length != imag.length)
        throw "Mismatched lengths";
    var n = real.length;
    if (n == 1) // Trivial transform
        return;
    var levels = -1;
    for (var i = 0; i < 32; i++) {
        if (1 << i == n)
            levels = i; // Equal to log2(n)
        }
    if (levels == -1)
        throw "Length is not a power of 2";
    var cosTable = new Array(n / 2);
    var sinTable = new Array(n / 2);
    for (var i = 0; i < n / 2; i++) {
        cosTable[i] = Math.cos(2 * Math.PI * i / n);
        sinTable[i] = Math.sin(2 * Math.PI * i / n);
    }

    // Bit-reversed addressing permutation
    for (var i = 0; i < n; i++) {
        var j = reverseBits(i, levels);
        if (j > i) {
            var temp = real[i];
            real[i] = real[j];
            real[j] = temp;
            temp = imag[i];
            imag[i] = imag[j];
            imag[j] = temp;
        }
    }

    // Cooley-Tukey decimation-in-time radix-2 FFT
    for (var size = 2; size <= n; size *= 2) {
        var halfsize = size / 2;
        var tablestep = n / size;
        for (var i = 0; i < n; i += size) {
            for (var j = i, k = 0; j < i + halfsize; j++, k += tablestep) {
                var tpre = real[j + halfsize] * cosTable[k] + imag[j + halfsize] * sinTable[k];
                var tpim = -real[j + halfsize] * sinTable[k] + imag[j + halfsize] * cosTable[k];
                real[j + halfsize] = real[j] - tpre;
                imag[j + halfsize] = imag[j] - tpim;
                real[j] += tpre;
                imag[j] += tpim;
            }
        }
    }

    // Returns the integer whose value is the reverse of the lowest 'bits' bits of the integer 'x'.
    function reverseBits(x, bits) {
        var y = 0;
        for (var i = 0; i < bits; i++) {
            y = (y << 1) | (x & 1);
            x >>>= 1;
        }
        return y;
    }
}

/*
 * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.
 * The vector can have any length. This requires the convolution function, which in turn requires the radix-2 FFT function.
 * Uses Bluestein's chirp z-transform algorithm.
 */
function transformBluestein(real, imag) {
    // Find a power-of-2 convolution length m such that m >= n * 2 + 1
    if (real.length != imag.length)
        throw "Mismatched lengths";
    var n = real.length;
    var m = 1;
    while (m < n * 2 + 1)
        m *= 2;

    // Trignometric tables
    var cosTable = new Array(n);
    var sinTable = new Array(n);
    for (var i = 0; i < n; i++) {
        var j = i * i % (n * 2); // This is more accurate than j = i * i
        cosTable[i] = Math.cos(Math.PI * j / n);
        sinTable[i] = Math.sin(Math.PI * j / n);
    }

    // Temporary vectors and preprocessing
    var areal = new Array(m);
    var aimag = new Array(m);
    for (var i = 0; i < n; i++) {
        areal[i] = real[i] * cosTable[i] + imag[i] * sinTable[i];
        aimag[i] = -real[i] * sinTable[i] + imag[i] * cosTable[i];
    }
    for (var i = n; i < m; i++)
        areal[i] = aimag[i] = 0;
    var breal = new Array(m);
    var bimag = new Array(m);
    breal[0] = cosTable[0];
    bimag[0] = sinTable[0];
    for (var i = 1; i < n; i++) {
        breal[i] = breal[m - i] = cosTable[i];
        bimag[i] = bimag[m - i] = sinTable[i];
    }
    for (var i = n; i <= m - n; i++)
        breal[i] = bimag[i] = 0;

    // Convolution
    var creal = new Array(m);
    var cimag = new Array(m);
    convolveComplex(areal, aimag, breal, bimag, creal, cimag);

    // Postprocessing
    for (var i = 0; i < n; i++) {
        real[i] = creal[i] * cosTable[i] + cimag[i] * sinTable[i];
        imag[i] = -creal[i] * sinTable[i] + cimag[i] * cosTable[i];
    }
}

/*
 * Computes the circular convolution of the given real vectors. Each vector's length must be the same.
 */
function convolveReal(x, y, out) {
    if (x.length != y.length || x.length != out.length)
        throw "Mismatched lengths";
    var zeros = new Array(x.length);
    for (var i = 0; i < zeros.length; i++)
        zeros[i] = 0;
    convolveComplex(x, zeros, y, zeros.slice(), out, zeros.slice());
}

/*
 * Computes the circular convolution of the given complex vectors. Each vector's length must be the same.
 */
function convolveComplex(xreal, ximag, yreal, yimag, outreal, outimag) {
    if (xreal.length != ximag.length || xreal.length != yreal.length || yreal.length != yimag.length || xreal.length != outreal.length || outreal.length != outimag.length)
        throw "Mismatched lengths";

    var n = xreal.length;
    xreal = xreal.slice();
    ximag = ximag.slice();
    yreal = yreal.slice();
    yimag = yimag.slice();

    transform(xreal, ximag);
    transform(yreal, yimag);
    for (var i = 0; i < n; i++) {
        var temp = xreal[i] * yreal[i] - ximag[i] * yimag[i];
        ximag[i] = ximag[i] * yreal[i] + xreal[i] * yimag[i];
        xreal[i] = temp;
    }
    inverseTransform(xreal, ximag);
    for (var i = 0; i < n; i++) { // Scaling (because this FFT implementation omits it)
        outreal[i] = xreal[i] / n;
        outimag[i] = ximag[i] / n;
    }
}
</script>
    <script>// check if AudioContext is supported by the current browser
if (!window.AudioContext) {
    if (!window.webkitAudioContex) {
        alert("no audiocontext found on this browser");
    }
    window.AudioContext = window.webkitAudioContext;
}

// define global object containing all audio informations
var Audiodata = {
    blockLen: 1024,
    signalLen: undefined,
    sampleRate: undefined,
    samples: undefined,
    numOfChannels: undefined,
    nPart: undefined,
    hopsize: undefined,
    overlap: 1 / 2,
    spectrogram: undefined,
    phase: undefined,
    groupDelay: undefined,
    instantFreqDev: undefined,
    windowFunction: "hann",
    cepstrum: undefined,
    modSpec: undefined,
    display: "Spectrum",
    windowValue: undefined,
    windowLen: undefined,
    wrapFreq: 250
};

// define a global audioContext
var reader = new FileReader();
var audioCtx = new AudioContext();

function loadAudio() {

    //  display the loading screen
    document.getElementById("loading").style.display = "block";
    document.getElementById("container").style.display = "block";

    // enable all the Buttons after loading an audio file
    enableButton();

    // get the first file data with the id "myAudio"
    var data = document.getElementById("myAudio").files[0];

    // read the data from myAudio as ArrayBuffer
    reader.readAsArrayBuffer(data);

    // save sampleRate as global variable
    Audiodata.sampleRate = audioCtx.sampleRate;

    // trigger the onload function to decode the Audiodata
    reader.onload = function() {
        audioCtx.decodeAudioData(reader.result).then(buffer => {

            myArrayBuffer = buffer;

            // get the number of channels
            Audiodata.numOfChannels = buffer.numberOfChannels;

            // get the samples of the first channel
            Audiodata.samples = buffer.getChannelData(0);

            // calculate the length of the audiosignal
            Audiodata.signalLen = Audiodata.samples.length;

            // trigger the drawWave() function (see waveform.js)
            drawWave();

            // trigger the processAudio() function
            processAudio();

            // hide the loading screen
            document.getElementById("loading").style.display = "none";
            document.getElementById("container").style.display = "none";
        });
    }
}

function processAudio() {

    // calculate the hopesize depending on the overlap
    Audiodata.hopsize = Math.round(Audiodata.blockLen - (Audiodata.blockLen * Audiodata.overlap));

    // calculate the total duration of the audiodata
    var duration = (Audiodata.signalLen / Audiodata.sampleRate);

    // write the duration into the playback time
    info.innerHTML = "00:00.0" +
        "&thinsp;/&thinsp;" + timeToString(duration, 1, 0);

    // calculate the number of sampleblocks
    Audiodata.nPart = Math.round((Audiodata.signalLen - Audiodata.blockLen) / Audiodata.hopsize);

    // check the maximum number of blocks ( = 32700);
    checkNumbOfBlocks();

    // create arrays for every display type
    Audiodata.spectrogram = new Array(Audiodata.nPart);
    Audiodata.phase = new Array(Audiodata.nPart);
    Audiodata.groupDelay = new Array(Audiodata.nPart);
    Audiodata.instantFreqDev = new Array(Audiodata.nPart);

    // call calculateDisplay() with current display type
    calculateDisplay(Audiodata.display);

    // draw the spectrogram (see spectrogram.js)
    drawSpec();

}

/*
 * calculate data for spectrogram.js depending on type (Types: "Spectrum",
 * "Phase", "Group Delay" and "Instantaneous Frequency Deviation")
 */
function calculateDisplay(type) {

    // calculate the choosen window (see calculateWindow())
    Audiodata.windowLen = linspace(0, Audiodata.blockLen, Audiodata.blockLen);
    Audiodata.windowValue = calculateWindow(Audiodata.windowLen, Audiodata.windowFunction);

    // cut the audiosamples into blocks and calculate the choosen data
    for (var i = 0; i < Audiodata.nPart; i++) {

        // slice the audio samples into equivalent blocks
        var sampleBlock = Audiodata.samples.slice(Audiodata.hopsize * i, Audiodata.blockLen + Audiodata.hopsize * i);

        // check if type is Instantaneous Frequency Deviation or not
        if (type != "Instantaneous Frequency Deviation") {
            for (var k = 0; k < Audiodata.blockLen; k++) {
                sampleBlock[k] = sampleBlock[k] * Audiodata.windowValue[k];
            }
            var [realPart,
                imagPart] = calculateFFT(sampleBlock);
        }

        // switch between the different display types
        switch (type) {
            case "Spectrum":
                Audiodata.spectrogram[i] = calculateAbs(realPart, imagPart);
                break;
            case "Phase":
                Audiodata.phase[i] = calculatePhase(realPart, imagPart);
                break;
            case "Group Delay":
                Audiodata.groupDelay[i] = calculateGroupDelay(realPart, imagPart);
                break;
            case "Instantaneous Frequency Deviation":
                Audiodata.instantFreqDev[i] = calculateInstantFreqDev(sampleBlock, Audiodata.windowFunction);
                break;
            default:
                alert("404 spectrogram not found!");
        }
    }
}

// calculate the fft depending on the given sampleblock
function calculateFFT(sampleBlock) {

    var imag = new Array(sampleBlock.length).fill(0);
    var real = sampleBlock;

    // call the fft from Nayuki (see fft.js for more information)
    transform(real, imag);

    return [real, imag];
}

// calculate the absolute value of the spectrogram data (see formula in instructions.html)
function calculateAbs(real, imag) {

    var absValue = new Array(Audiodata.blockLen / 2 + 1);

    for (i = 0; i < absValue.length; i++) {
        absValue[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]);
    }
    return absValue;
}

// calculate the phase of the spectrogram data (see formula in instructions.html)
function calculatePhase(real, imag) {

    var phaseValue = new Array(real.length / 2 + 1);

    for (i = 0; i < phaseValue.length; i++) {
        phaseValue[i] = Math.atan2(imag[i], real[i]);
    }
    return phaseValue;
}

/*
 * calculate the group delay using calcluatePhase() and linspace() (see formula
 * in instructions.html)
 */
function calculateGroupDelay(real, imag) {

    var phase = calculatePhase(real, imag);

    var freqVector = linspace(0, Audiodata.sampleRate / 2, Audiodata.blockLen / 2);

    var dOmega = (freqVector[2] - freqVector[1]) * 2 * Math.PI;

    var dPhase = diff(phase);

    var groupDelay = new Array(dPhase.length);

    for (var k = 0; k < dPhase.length; k++) {
        if (dPhase[k] > Math.PI) {
            dPhase[k] = dPhase[k] - 2 * Math.PI;
        } else if (dPhase[k] < (-1 * Math.PI)) {
            dPhase[k] = dPhase[k] + 2 * Math.PI;
        }
        groupDelay[k] = -1 * dPhase[k] / dOmega;
    }
    return groupDelay;
}

/*
 * calculate the instantaneous frequency deviation for more informations see
 * the instructions.html website
 */
function calculateInstantFreqDev(sampleBlock, windowType) {

    var InstHopsize = Audiodata.sampleRate / Audiodata.wrapFreq;

    var newSampleBlockLen = Math.round(sampleBlock.length - InstHopsize);

    var windowLen = linspace(0, newSampleBlockLen, newSampleBlockLen);

    var window = calculateWindow(windowLen, windowType);

    var firstSampleBlock = sampleBlock.slice(0, newSampleBlockLen);

    var secondSampleBlock = sampleBlock.slice(sampleBlock.length - newSampleBlockLen, sampleBlock.length);

    for (var i = 0; i < newSampleBlockLen; i++) {
        firstSampleBlock[i] = firstSampleBlock[i] * window[i];
        secondSampleBlock[i] = secondSampleBlock[i] * window[i];
    }

    var [firstReal,
        firstImag] = calculateFFT(firstSampleBlock);
    var [secondReal,
        secondImag] = calculateFFT(secondSampleBlock);

    var firstPhase = calculatePhase(firstReal, firstImag);

    var secondPhase = calculatePhase(secondReal, secondImag);

    var instantFreq = new Array(newSampleBlockLen / 2 + 1).fill(0);
    var instantFreqDev = new Array(instantFreq.length).fill(0);

    var freq = linspace(0, Audiodata.sampleRate / 2, instantFreq.length);

    for (var k = 0; k < instantFreq.length; k++) {
        var dPhase = secondPhase[k] - firstPhase[k];

        instantFreq[k] = dPhase * Audiodata.wrapFreq / (2 * Math.PI);

        instantFreq[k] = instantFreq[k] + Math.round((freq[k] - instantFreq[k]) / Audiodata.wrapFreq) * Audiodata.wrapFreq;

        instantFreqDev[k] = instantFreq[k] - freq[k];
    }
    return instantFreqDev;
}

/*
 * calculate the different windows depending on the window length and the
 * window type (Types: "hann", "hannpoisson", "consine", "hamming",
 *"flat-top", "blackman" and "rect") see instructions.html
 */
function calculateWindow(windowLen, type) {

    var window = new Array(windowLen.length);

    switch (type) {
        case "hann":
            for (i = 0; i < windowLen.length; i++) {
                window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * windowLen[i] / (windowLen.length - 1)));
            }
            break;
        case "hannpoisson":
            var alpha = 2;

            for (i = 0; i < windowLen.length; i++) {
                window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * windowLen[i] / (windowLen.length - 1))) * Math.exp((-alpha * Math.abs(windowLen.length - 1 - (2 * windowLen[i]))) / (windowLen.length - 1));
            }
            break;
        case "cosine":
            for (i = 0; i < windowLen.length; i++) {
                window[i] = Math.cos(((Math.PI * windowLen[i]) / (windowLen.length)) - (Math.PI / 2));
            }
            break;
        case "hamming":
            var alpha = 0.54;
            var beta = 1 - alpha;

            for (i = 0; i < windowLen.length; i++) {
                window[i] = alpha - beta * Math.cos((2 * Math.PI * windowLen[i]) / (windowLen.length - 1));
            }
            break;
        case "flat-top":
            var alpha = [1, 1.93, 1.29, 0.388, 0.028];

            for (i = 0; i < windowLen.length; i++) {
                window[i] = alpha[0] - alpha[1] * Math.cos(2 * Math.PI * windowLen[i] / (windowLen.length - 1)) + alpha[2] * Math.cos(4 * Math.PI * windowLen[i] / (windowLen.length - 1)) - alpha[3] * Math.cos(6 * Math.PI * windowLen[i] / (windowLen.length - 1)) + alpha[4] * Math.cos(8 * Math.PI * windowLen[i] / (windowLen.length - 1));
            }
            break;
        case "blackman":
            var alpha = 0.16;
            var alpha0 = (1 - alpha) / 2;
            var alpha1 = 1 / 2;
            var alpha2 = alpha / 2;

            for (i = 0; i < windowLen.length; i++) {
                window[i] = alpha0 - alpha1 * Math.cos((2 * Math.PI * windowLen[i]) / (windowLen.length - 1)) + alpha2 * Math.cos((4 * Math.PI * windowLen[i]) / (windowLen.length - 1));
            }
            break;
        case "rect":
            window.fill(1);
            break;
        default:
            alert("no window type is choosen!");
    }
    return window;
}

/*
 * implementation of the linspace function make use of start value, end value
 * and the number of points between the start and end index
 */
function linspace(startIdx, endIdx, n) {

    var linVector = new Array(n);

    for (var i = 0; i < n; i++) {
        linVector[i] = startIdx + (i * (endIdx - startIdx) / n);
    }
    linVector[0] = startIdx;
    linVector[n - 1] = endIdx;
    return linVector;
}

// caluclate the difference between each element of an array
function diff(array) {

    var difference = new Array(array.length - 1);

    for (var i = 0; i < difference.length; i++) {
        difference[i] = array[i + 1] - array[i];
    }
    return difference;
}

// check if the maximum block number for canvas is given
function checkNumbOfBlocks() {

    var maxBlockNumb = 32767;

    if (Audiodata.nPart > maxBlockNumb) {
        alert("Reached the maximum number of blocks.\n Data not fully displayed!");
        Audiodata.nPart = maxBlockNumb;
    }
}
</script>
    <script>
        var SpectroData = {
    colorScale: undefined,
    scaleFactorWidth: undefined,
    scaleFactorHeight: undefined,
    scaleOfsetLeft: 24,
    scaleOfsetBottom: 28,
    scrollPositionX: 0,
    scrollPositionY: 0,
    TypeColorScale: 1,
    specLevelHigh: -30,
    specLevelLow: -90,
    specLevelWidth: undefined,
    strgPressed: 0,
    shiftPressed: 0,
    specData: undefined,
    cWidth: undefined,
    cHigh: undefined,
    specWidth: undefined,
    specHight: undefined,
    endTimeSelection: Audiodata.signalLen / Audiodata.sampleRate,
    securityOffset: 10
};

// Creating a temp canvas that will hold the unscaled spectrogram data
var tempCanvas = document.createElement("canvas"),
    tempCtx = tempCanvas.getContext("2d");

// Main function that fills most global variables with numbers and creats the
// colorscales
function drawSpec() {

    SpectroData.specLevelWidth = Math.abs(SpectroData.specLevelHigh - SpectroData.specLevelLow)
    var canvas = document.getElementById("canvasSpec")
    var ctx = canvas.getContext("2d")
    var canvasSpecLine = document.getElementById("canvasSpecLine")
    var ctxLine = canvasSpecLine.getContext("2d")
    var div = document.getElementById("canvasDivSpec")
    div.addEventListener("scroll", setscrollPosition);
    window.addEventListener("keydown", onKeyDown)
    window.addEventListener("keyup", onKeyUp)
    var divWidth = div.offsetWidth;
    var divHeight = div.offsetHeight;
    // Reset Transformastion and scaling of the spoectrogram canvas
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    SpectroData.cWidth = canvas.width;
    SpectroData.cHigh = canvas.height;

    //Importing time-frequency-data to local variable
    switch (Audiodata.display) {
        case "Spectrum":
            SpectroData.specData = Audiodata.spectrogram;
            break;
        case "Phase":
            SpectroData.specData = Audiodata.phase;
            break;
        case "Instantaneous Frequency Deviation":
            SpectroData.specData = Audiodata.instantFreqDev
            break;
        case "Group Delay":
            SpectroData.specData = Audiodata.groupDelay;
            break;
    }

    // Defining varables with no of spectrograms
    SpectroData.specWidth = SpectroData.specData.length;
    SpectroData.specHight = SpectroData.specData[1].length;

    // Setting size of the temp canvas to fit the spectrogram data
    tempCtx.clearRect(0, 0, SpectroData.specWidth, SpectroData.specHight);
    tempCanvas.width = SpectroData.specWidth;
    tempCanvas.height = SpectroData.specHight;

    // Create color scales
    createViridis();
    createGray();
    createJet();
    createPlasma();
    createTwilight();

    // Start draw spectrogram
    draw();

    // Adding fuction callbacks for zoom buttons
    var plusX = document.getElementById('plusX')
    var minusX = document.getElementById('minusX')
    var plusY = document.getElementById('plusY')
    var minusY = document.getElementById('minusY')
    plusX.addEventListener("click", function() {
        zoomTime(-1)
    }, false);
    minusX.addEventListener("click", function() {
        zoomTime(1)
    }, false);
    plusY.addEventListener("click", function() {
        zoomFreq(-1)
    }, false);
    minusY.addEventListener("click", function() {
        zoomFreq(1)
    }, false);

    //create eventlistener for mouse actions and play button
    playButton.addEventListener("click", toggleSound);
    canvasSpecLine.addEventListener("click", startPlayHere)
    canvasSpecLine.addEventListener('mousemove', displayMousePosition);
    canvasSpecLine.addEventListener("dblclick", scaleFullSpec);

    // Callback function of single click event on the spectrogram, to set the
    // playback start position at klick position and create the red line at this positon
    function startPlayHere(evt) {
        var mousePos = getMousePos(canvas, evt)
        mouseTime = (Audiodata.signalLen / Audiodata.sampleRate) / canvas.width * mousePos.x

        if (isPlaying) {
            toggleSound()
        }
        startOffset = mouseTime

        drawLineKlick(mouseTime)
        drawLineKlickWave(mouseTime)
    }


    // Function for zooming the time axes only
    function zoomTime(delta) {

        var factor;
        if (delta < 0) {
            factor = 1.2;
        } else if (delta > 0) {
            factor = 0.8;
        } else {
            factor = 1;
        }
            // Checking if the new canvas size is smaler than the maximum possible
            // size, but also bigger then the size of the surrounding div. If this is
            // the case, the canvases are scaled to the new size
        if (canvas.width * factor < 32767 &&
          (canvas.width * factor) * canvas.height < 268435456 &&
          canvas.width * factor > divWidth &&
          canvasSpecScale.width * factor <= (tempCanvas.width * 4)) {

            canvasSpecScale.width = canvas.width * factor + SpectroData.scaleOfsetLeft
            canvas.width = canvas.width * factor;
            SpectroData.cWidth = canvas.width;
            canvasSpecLine.width = canvasSpecLine.width * factor

    scaleSpectrogramm()
            // If the new size will be smaler then the surrounding div, the size
            // of the canvases is set to the size of the div
        } else if (canvas.width * factor < 32767 &&
          (canvas.width * factor) * canvas.height < 268435456 &&
          canvas.width * factor < divWidth &&
          canvasSpecScale.width * factor <= (tempCanvas.width * 4)) {

            canvasSpecScale.width = divWidth
            canvas.width = divWidth - SpectroData.scaleOfsetLeft
            SpectroData.cWidth = canvas.width;
            canvasSpecLine.width = divWidth - SpectroData.scaleOfsetLeft

      scaleSpectrogramm()
        }
    }

    // Function for zooming freq axes only
    function zoomFreq(delta) {

        var factor;
        if (delta < 0) {
            factor = 1.1;
        } else if (delta > 0) {
            factor = 0.9;
        } else {
            factor = 1;
        }

        // Checking if the new canvas size is smaler than the maximum possible
        // size, but also bigger then the size of the surrounding div. If this is
        // the case, the canvases are scaled to the new size
        if (canvasSpecScale.height * factor < 32767 &&
          (canvasSpecScale.height * factor) * canvasSpecScale.width < 268435456 &&
           canvasSpecScale.height * factor > divHeight &&
           canvasSpecScale.height * factor <= (tempCanvas.height * 2.5)) {

            canvasSpecScale.height = canvas.height * factor + SpectroData.scaleOfsetBottom
            canvas.height = canvas.height * factor;
            SpectroData.cHigh = canvas.height;
            canvasSpecLine.height = canvasSpecLine.height * factor;

          scaleSpectrogramm()
            // If the new size will be smaler then the surrounding div, the size
            // of the canvases is set to the size of the div
        } else if (canvasSpecScale.height * factor < 32767 &&
          (canvasSpecScale.height * factor) * canvasSpecScale.width < 268435456 &&
          canvasSpecScale.height * factor < divHeight &&
          canvasSpecScale.height * factor <= (tempCanvas.height * 2.5)) {

            canvasSpecScale.height = divHeight
            canvas.height = divHeight - SpectroData.scaleOfsetBottom
            SpectroData.cHigh = canvas.height;
            canvasSpecLine.height = divHeight - SpectroData.scaleOfsetBottom

        scaleSpectrogramm()
        }
    }


}

// Function for drawing a new spectrogram
function draw() {
    var canvas = document.getElementById("canvasSpec");
    var ctx = canvas.getContext("2d");
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    if (SpectroData.TypeColorScale == 1) {
        var colorScale = viridisScale;
    } else if (SpectroData.TypeColorScale == 2) {
        var colorScale = grayScale;
    } else if (SpectroData.TypeColorScale == 3) {
        var colorScale = jetScale;
    } else if (SpectroData.TypeColorScale == 4) {
        var colorScale = plasmaScale;
    }
    if (Audiodata.display === "Phase" || Audiodata.display === "Group Delay") {
        var colorScale = twilightScale;
    } else if (Audiodata.display === "Instantaneous Frequency Deviation") {
        var colorScale = sunlightScale;
    }

    SpectroData.colorScale = colorScale;

    var noOfColorSteps = colorScale[1].length;

    // clear canvas from previous data
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // create image data variable
    var pictureData = ctx.createImageData(SpectroData.specWidth, SpectroData.specHight);

    // create counter variable for the numbers in the ImageData variable
    var nPictureData = 0;

    switch (Audiodata.display) {
        case "Spectrum":
            for (var j = SpectroData.specHight - 1; j > 0; j--) {

                for (var i = 0; i < SpectroData.specWidth; i++) {
                    // scaling the input Data onto the colorscale
                    point = 20 * Math.log10(SpectroData.specData[i][j] / Audiodata.blockLen);
                    point += Math.abs(SpectroData.specLevelLow);
                    point = Math.max(point, 0);
                    point = Math.min(point, SpectroData.specLevelWidth);
                    point /= Math.abs(SpectroData.specLevelWidth);
                    point *= (noOfColorSteps - 1);

                    point = Math.floor(point);
                    if (point > noOfColorSteps - 1) {
                        point = noOfColorSteps - 1;
                    }

                    for (var kk = 0; kk < 3; kk++) {
                        pictureData.data[nPictureData] = Math.round(colorScale[kk][point]);
                        nPictureData++;
                    }
                    pictureData.data[nPictureData] = 255;
                    nPictureData++;
                }
            }
            break;
        case "Phase":
            for (var j = SpectroData.specHight - 1; j > 0; j--) {

                for (var i = 0; i < SpectroData.specWidth; i++) {
                    point = SpectroData.specData[i][j];
                    point += Math.PI;
                    point *= noOfColorSteps - 1;
                    point /= 2 * Math.PI;
                    point = Math.floor(point);
                    if (point > noOfColorSteps - 1) {
                        point = noOfColorSteps - 1;
                    }

                    for (var kk = 0; kk < 3; kk++) {
                        pictureData.data[nPictureData] = Math.round(colorScale[kk][point]);
                        nPictureData++;
                    }
                    pictureData.data[nPictureData] = 255;
                    nPictureData++;
                }
            }
            break;
        case "Instantaneous Frequency Deviation":
            for (var j = SpectroData.specHight - 1; j > 0; j--) {

                for (var i = 0; i < SpectroData.specWidth; i++) {
                    point = SpectroData.specData[i][j];
                    point += Audiodata.wrapFreq / 2;
                    point *= noOfColorSteps - 1;
                    point /= Audiodata.wrapFreq;
                    point = Math.floor(point);
                    if (point > noOfColorSteps - 1) {
                        point = noOfColorSteps - 1;
                    }

                    for (var kk = 0; kk < 3; kk++) {
                        pictureData.data[nPictureData] = Math.round(colorScale[kk][point]);
                        nPictureData++;
                    }
                    pictureData.data[nPictureData] = 255;
                    nPictureData++;
                }
            }
            break;
        case "Group Delay":
            for (var j = SpectroData.specHight - 1; j > 0; j--) {

                for (var i = 0; i < SpectroData.specWidth; i++) {
                    point = SpectroData.specData[i][j];
                    point += 0.5 * ((1 / Audiodata.sampleRate) * Audiodata.blockLen)
                    point *= 1000
                    point *= noOfColorSteps - 1;
                    point /= ((1 / Audiodata.sampleRate) * Audiodata.blockLen) * 1000
                    point = Math.floor(point);
                    if (point > noOfColorSteps - 1) {
                        point = noOfColorSteps - 1;
                    }

                    for (var kk = 0; kk < 3; kk++) {
                        pictureData.data[nPictureData] = Math.round(colorScale[kk][point]);
                        nPictureData++;
                    }
                    pictureData.data[nPictureData] = 255;
                    nPictureData++;
                }
            }
            break;
    }

    // Putting imageData onto the temp canvas
    tempCtx.putImageData(pictureData, 0, 0);
    drawLegend(colorScale)
    scaleSpectrogramm()

}

// Function that draws a red line at playback position
function drawLineKlick(mouseTime) {
    canvasSpecLine = document.getElementById("canvasSpecLine")
    canvas = document.getElementById("canvasSpec")
    ctxLine = canvasSpecLine.getContext("2d")
    mousePos = (mouseTime * canvas.width) / (Audiodata.signalLen / Audiodata.sampleRate)
    ctxLine.clearRect(0, 0, canvasSpecLine.width, canvasSpecLine.height)
    ctxLine.fillStyle = 'rgb(' + 255 + ',' + 0 + ',' + 0 + ')';
    ctxLine.fillRect(mousePos, 0, 2, canvasSpecLine.height);
    info.innerHTML = timeToString((mouseTime), 1, 0) + "/" + timeToString((Audiodata.signalLen / Audiodata.sampleRate), 1, 0);

    drawLinePlay()
}

// In this function the spectrogram values for the actual mouse position are
// extracted  from the raw spectrogram data and then displayed in the upper left
// cornder of the spectrogram
function displayMousePosition(evt) {
    var canvas = document.getElementById("canvasSpec");
    var specTime = document.getElementById("specTime");
    var specFreq = document.getElementById("specFreq");
    var magnitute = document.getElementById("magnitute");
    var mousePos = getMousePos(canvas, evt);
    sigLenSec = Audiodata.signalLen / Audiodata.sampleRate;
    mouseX = Math.round((sigLenSec / canvas.width * mousePos.x) * 100) / 100;
    mouseY = Math.round(((Audiodata.sampleRate / 2) / canvas.height) * (canvas.height - mousePos.y))

    specTime.innerHTML = 'Time: ' + timeToString(mouseX, 1, 1)
    specFreq.innerHTML = 'Freq: ' + mouseY + ' Hz';
    point = SpectroData.specData[Math.round(mousePos.x / SpectroData.scaleFactorWidth)]
        [Math.round(((canvas.height - 1) - (mousePos.y)) / SpectroData.scaleFactorHeight)]

    switch (Audiodata.display) {
        case "Spectrum":
            if (!isNaN(point)) {
                point = 20 * Math.log10(point / Audiodata.blockLen);
                point = Math.max(SpectroData.specLevelLow, point);
                point = Math.min(point, SpectroData.specLevelHigh)
                magnitute.innerHTML = 'Level: ' + Math.round(point) + ' dB'
            }
            break;
        case "Phase":
            if (!isNaN(point)) {
                point /= Math.PI;
                magnitute.innerHTML = 'Phase: ' + Math.round(point * 100) / 100 + ' \u03C0'
            }
            break;
        case "Instantaneous Frequency Deviation":
            magnitute.innerHTML = "IFD: " + Math.round(point) + " Hz"
            break
        case "Group Delay":
            point += 0.5 * ((1 / Audiodata.sampleRate) * Audiodata.blockLen);
            if (!isNaN(point)) {
                point *= 1000
                magnitute.innerHTML = "Group Delay: " + Math.round(point * 100) / 100 + " ms"
            }
            break;
    }
};

// Function that draws the red play position line on the canvas while playback
function drawLinePlay() {
    // Getting all elements needed for the function
    var canvasSpecLine = document.getElementById("canvasSpecLine")
    var ctxLine = canvasSpecLine.getContext("2d")
    var div = document.getElementById("canvasDivSpec")

    // If the function is called when nothing is played, nothing happens
    if (isPlaying) {
        // Calculation of actual line Position from actual playback time
        var linePosition = Math.floor(canvasSpecLine.width / (Audiodata.signalLen / Audiodata.sampleRate) * (audioCtx.currentTime - startTime + startOffset))

        // If the position is outside the div, the canvas is scrolled
        if (linePosition <= SpectroData.scrollPositionX - SpectroData.scaleOfsetLeft) {
            div.scrollLeft = linePosition + SpectroData.scaleOfsetLeft - 50
        }

        // Drawing the line
        ctxLine.clearRect(0, 0, canvasSpecLine.width, canvasSpecLine.height)

        ctxLine.fillStyle = 'rgb(' + 255 + ',' + 0 + ',' + 0 + ')';
        ctxLine.fillRect(linePosition, 0, 2, canvasSpecLine.height);
        if (linePosition >= SpectroData.scrollPositionX + div.offsetWidth - SpectroData.scaleOfsetLeft) {
            div.scrollLeft = div.scrollLeft + div.offsetWidth - 50
        }
        // Calling the function again depended on the actual load of the computer
        window.requestAnimationFrame(drawLinePlay)
    }
}

// Functions that draws the legend for the spectrogram
function drawLegend(colorScale) {
    SpectroData.specLevelWidth = Math.abs(SpectroData.specLevelHigh - SpectroData.specLevelLow);
    legCanvas = document.getElementById("canvasLegend");
    ctxLegend = legCanvas.getContext("2d");
    ctxLegend.setTransform(1, 0, 0, 1, 0, 0);
    ctxLegend.clearRect(0, 0, canvasLegend.width, canvasLegend.height)

    var tempCanvasLEgend = document.createElement("canvas"),
        tempCtxLegend = tempCanvasLEgend.getContext("2d");

    tempCtxLegend.clearRect(0, 0, tempCanvasLEgend.width, tempCanvasLEgend.height);
    tempCanvasLEgend.width = 300
    tempCanvasLEgend.height = 75;

    for (var i = 0; i < 100; i++) {
        for (var j = 0; j < legCanvas.height; j++) {
            tempCtxLegend.fillStyle = 'rgb(' + Math.floor(colorScale[0][i]) + ',' + Math.floor(colorScale[1][i]) + ',' + Math.floor(colorScale[2][i]) + ')';
            tempCtxLegend.fillRect(i * 3, j, 3, 1);
        }
    }
    // Draw the image from the temp canvas to the scaled canvas
    ctxLegend.clearRect(0, 0, canvasLegend.width, canvasLegend.height);
    ctxLegend.drawImage(tempCanvasLEgend, 0, 0);

    ctxLegend.clearRect(0, canvasLegend.height - 15, canvasLegend.width * 2, canvasLegend.height)
    ctxLegend.font = "700 14px Arial";
    switch (Audiodata.display) {
        case "Spectrum":
            ctxLegend.fillText(SpectroData.specLevelLow + ' dB', 2, canvasLegend.height - 1);
            ctxLegend.fillText(SpectroData.specLevelLow + (SpectroData.specLevelWidth / 2) + ' dB', (canvasLegend.width / 2) - 15, canvasLegend.height - 1);
            ctxLegend.fillText(SpectroData.specLevelHigh + ' dB', (canvasLegend.width - 2) - 45, canvasLegend.height - 1);
            break;
        case "Phase":
            ctxLegend.fillText('-\u03C0', 2, canvasLegend.height - 1);
            ctxLegend.fillText(0, (canvasLegend.width / 2) - 4, canvasLegend.height - 1);
            ctxLegend.fillText('\u03C0', (canvasLegend.width - 2) - 10, canvasLegend.height - 1);
            break;
        case "Group Delay":
            ctxLegend.fillText(0 + 'ms', 2, canvasLegend.height - 1);
            ctxLegend.fillText((((Audiodata.blockLen / Audiodata.sampleRate) * 1000) / 2).toFixed(1) + 'ms', (canvasLegend.width / 2) - 15, canvasLegend.height - 1);
            ctxLegend.fillText(((Audiodata.blockLen / Audiodata.sampleRate) * 1000).toFixed(1) + 'ms', (canvasLegend.width - 2) - 45, canvasLegend.height - 1);
            break;
        case "Instantaneous Frequency Deviation":
            ctxLegend.fillText((-1 * Audiodata.wrapFreq / 2).toFixed(0) + 'Hz', 2, canvasLegend.height - 1);
            ctxLegend.fillText(0 + 'Hz', (canvasLegend.width / 2) - 15, canvasLegend.height - 1);
            ctxLegend.fillText((Audiodata.wrapFreq / 2).toFixed(0) + 'Hz', (canvasLegend.width - 2) - 45, canvasLegend.height - 1);
            break;
    }

    ctxLegend.beginPath()
    ctxLegend.moveTo(1, (canvasLegend.height - 25))
    ctxLegend.lineTo(1, (canvasLegend.height - 15))
    ctxLegend.lineTo((canvasLegend.width / 2), canvasLegend.height - 15)
    ctxLegend.lineTo((canvasLegend.width / 2), canvasLegend.height - 25)
    ctxLegend.moveTo((canvasLegend.width / 2), canvasLegend.height - 15)
    ctxLegend.lineTo((canvasLegend.width - 1), canvasLegend.height - 15)
    ctxLegend.lineTo((canvasLegend.width - 1), canvasLegend.height - 25)
    ctxLegend.strokeStyle = '#100719';
    ctxLegend.lineWidth = 2;
    ctxLegend.stroke();
}

// Function draws the x and y scale to the spectrogram
function drawScale() {
    var canvas = document.getElementById('canvasSpec');
    div = document.getElementById('canvasDivSpec')
    var canvasSpecScale = document.getElementById('canvasSpecScale');
    var ctxScale = canvasSpecScale.getContext('2d');
    var divWidth = div.offsetWidth;
    var divHeight = div.offsetHeight;
    var freqMax = Audiodata.sampleRate / 2;
    var trackLenSec = Audiodata.signalLen / Audiodata.sampleRate;
    var freqPerLine = (Audiodata.sampleRate / 2) / canvas.height;
    var timePerColumn = (Audiodata.signalLen / Audiodata.sampleRate) / canvas.width
    var timePerSide = (div.offsetWidth - SpectroData.scaleOfsetLeft) * timePerColumn
    var freqPerSide = (div.offsetHeight - SpectroData.scaleOfsetBottom) * freqPerLine

    var logTime = Math.log10(timePerSide);
    logTime = Math.pow(10, Math.floor(logTime))
    var logFreq = Math.log10(freqPerSide);
    logFreq = Math.pow(10, Math.floor(logFreq))

    var minDistanceNumbersX = 50;
    var maxDistanceNumbersX = 400;
    var minDistanceNumbersY = 25;
    var maxDistanceNumbersY = 400;
    var tickNumX = NaN;
    var tickNumY = NaN;
    var freqPerLine = freqMax / canvas.height;
    var timePerColumn = trackLenSec / canvas.width

    var stepsX = 100;

    // Finding the best fit scale size for the actual canvas size
    while (isNaN(tickNumX)) {
        for (var kk = minDistanceNumbersX; kk <= maxDistanceNumbersX; kk++) {
            var time = kk * timePerColumn;
            var quarter = time % (logTime / 4);
            var half = time % (logTime / 2);
            var full = time % logTime;
            if (quarter <= (timePerColumn) && (logTime / 4) * Math.ceil(canvas.width / kk) >= Math.floor(trackLenSec)) {
                stepsX = kk;
                tickNumX = logTime / 4;
                break
            } else if (half <= (timePerColumn) && (logTime / 2) * Math.ceil(canvas.width / kk) >= Math.floor(trackLenSec)) {
                stepsX = kk;
                tickNumX = logTime / 2
                break
            } else if (full <= (timePerColumn) && logTime * Math.ceil(canvas.width / kk) >= Math.floor(trackLenSec)) {
                stepsX = kk;
                tickNumX = logTime
                break
            }
        }
        if (isNaN(tickNumX)) {
            logTime *= 10
        }
    }

    var stepsY = 25;

    while (isNaN(tickNumY)) {

        for (var kk = minDistanceNumbersY; kk <= maxDistanceNumbersY; kk++) {
            var freq = kk * freqPerLine;
            var quarter = freq % (logFreq / 4);
            var half = freq % (logFreq / 2);
            var full = freq % logFreq;

            if (quarter <= (freqPerLine * 2) && (logFreq / 4) * Math.ceil(canvas.height / kk) >= 20000) {
                stepsY = kk;
                tickNumY = logFreq / 4;
                break;
            } else if (half <= freqPerLine * 2 && (logFreq / 2) * Math.ceil(canvas.height / kk) >= 20000) {
                stepsY = kk;
                tickNumY = logFreq / 2;
                break;
            } else if (full <= freqPerLine * 2 && (logFreq) * Math.ceil(canvas.height / kk) >= 20000) {
                stepsY = kk;
                tickNumY = logFreq;
                break;
            }
        }
        if (isNaN(tickNumY)) {
            logFreq *= 5
        }
    }

    ctxScale.clearRect(0, 0, canvasSpecScale.width, canvasSpecScale.height);
    ctxScale.beginPath();
    ctxScale.moveTo(SpectroData.scaleOfsetLeft, 0);
    ctxScale.lineTo(SpectroData.scaleOfsetLeft, canvasSpecScale.height - SpectroData.scaleOfsetBottom)
    ctxScale.lineTo(canvasSpecScale.width - 1, canvasSpecScale.height - SpectroData.scaleOfsetBottom)
    ctxScale.strokeStyle = 'black';
    ctxScale.lineWidth = 1;
    ctxScale.stroke();
    ctxScale.beginPath();

    ctxScale.font = "bold 12px Verdana";

    // Drawing ticks and tick labels of the y-axis
    for (var kk = canvasSpecScale.height - SpectroData.scaleOfsetBottom; kk >= 0; kk -= stepsY) {
        ctxScale.moveTo(SpectroData.scaleOfsetLeft, kk);
        ctxScale.lineTo(SpectroData.scaleOfsetLeft - 5, kk)
        ctxScale.stroke();

        ctxScale.fillText(tickNumY * ((canvasSpecScale.height - SpectroData.scaleOfsetBottom - kk) / stepsY), 1, kk, SpectroData.scaleOfsetLeft - 2);
    }
    // Drawing ticks and tick labels of the x-axis
    for (var kk = 0; kk <= canvasSpecScale.width; kk += stepsX) {
        ctxScale.moveTo(kk + SpectroData.scaleOfsetLeft, canvasSpecScale.height - SpectroData.scaleOfsetBottom);
        ctxScale.lineTo(kk + SpectroData.scaleOfsetLeft, canvasSpecScale.height - SpectroData.scaleOfsetBottom + 5)
        ctxScale.stroke();
        ctxScale.fillText(timeToString(tickNumX * (kk / stepsX), 0, tickNumX), kk + SpectroData.scaleOfsetLeft - 5, canvasSpecScale.height - SpectroData.scaleOfsetBottom + 15, SpectroData.scaleOfsetLeft - 2);
    }
}

// This functions changes the variables for the actual scroll position of the canvas
// in the div to the new values if the canvas is scrolled
function setscrollPosition() {
    div = document.getElementById('canvasDivSpec')
    SpectroData.scrollPositionX = div.scrollLeft,
        SpectroData.scrollPositionY = div.scrollTop
    section = getSectionDisplayed()
    drawSelection(section.min, 2, section.max);
}

// Function that returns the actual mouse position in the canvas
function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return {
        x: Math.floor(evt.clientX - rect.left),
        y: Math.floor(evt.clientY - rect.top)
    };
}

// Function that sets indicators for pressed key to one if the key is pressed
function onKeyDown(evt) {
    switch (evt.code) {
        case "ShiftLeft":
            SpectroData.shiftPressed = 1;
            break;
        case "ControlLeft":
            SpectroData.strgPressed = 1;
            break;
    }
}

// Function that sets indicators for pressed key back to zero afer the key is released
function onKeyUp(evt) {
    switch (evt.code) {
        case "ShiftLeft":
            SpectroData.shiftPressed = 0;
            break;
        case "ControlLeft":
            SpectroData.strgPressed = 0;
            break;
    }
}

// Function that zooms the spectrogram to the section that is selected in the Waveform
function zoomToSelection(timeStart, timeEnd) {
    var canvas = document.getElementById("canvasSpec")
    var ctx = canvas.getContext("2d")
    var div = document.getElementById("canvasDivSpec")
    var canvasSpecLine = document.getElementById("canvasSpecLine")
    var divWidth = div.offsetWidth;

    // If a area is selected from the right to the left, start and endtime are switched here
    if (timeEnd < timeStart) {
        var tempTimeStart = timeStart;
        timeStart = timeEnd;
        timeEnd = tempTimeStart;
        SpectroData.endTimeSelection = timeEnd
            // If start and endtime are the same, the user hast just clicked without
            // marking an area. No selection area is set then, but the spectrogram
            // canvas is scrolled that the marked line is near the left end of the div
    } else if (timeEnd == timeStart) {
        SpectroData.endTimeSelection = Audiodata.signalLen / Audiodata.sampleRate;
        div.scrollLeft = (timeStart / ((Audiodata.signalLen / Audiodata.sampleRate) / canvas.width)) - divWidth / 8;
        return;
    }
    var lengthSelect = (timeEnd - timeStart);
    var freqPerLine = (Audiodata.sampleRate / 2) / canvas.height;
    var timePerColumn = (Audiodata.signalLen / Audiodata.sampleRate) / canvas.width
    var timePerSide = (divWidth - SpectroData.scaleOfsetLeft) * timePerColumn

    if (timePerSide == lengthSelect) {
        var factor = 1;

    }
    if (timePerSide != lengthSelect) {
        factor = timePerSide / (lengthSelect * 1.1);
    }

    if (canvas.width * factor < 32767 && (canvas.width * factor) * canvas.height < 268435456
    && canvas.width * factor > divWidth) {

        canvasSpecScale.width = canvas.width * factor + SpectroData.scaleOfsetLeft
        canvas.width = canvas.width * factor;
        SpectroData.cWidth = canvas.width;
        canvasSpecLine.width = canvasSpecLine.width * factor

        scaleSpectrogramm()

        var lineStart = (timeStart * canvas.width) / (Audiodata.signalLen / Audiodata.sampleRate);
        div.scrollLeft = lineStart;
    }
}

// This function returns the lines of the spec canvas that are displayed in the Div
function getSectionDisplayed() {
    var canvas = document.getElementById("canvasSpec")
    var div = document.getElementById("canvasDivSpec")
    return {
        min: SpectroData.scrollPositionX * ((Audiodata.signalLen / Audiodata.sampleRate) / canvas.width),
        max: (SpectroData.scrollPositionX + div.offsetWidth) * ((Audiodata.signalLen / Audiodata.sampleRate) / canvas.width)
    };
}

// Callback for doublecklick for resizing the spectrogram to show the full
// spectrogram in the window
function scaleFullSpec() {
    // getting all neded elements
    var canvas = document.getElementById("canvasSpec")
    var ctx = canvas.getContext("2d")
    var canvasSpecLine = document.getElementById("canvasSpecLine")
    var div = document.getElementById("canvasDivSpec")
    var canvasSpecScale = document.getElementById('canvasSpecScale');
    // Resizing all three canvases
    canvas.width = div.offsetWidth - SpectroData.scaleOfsetLeft-20
    canvas.height = div.offsetHeight - SpectroData.scaleOfsetBottom-20
    SpectroData.cWidth = canvas.width;
    SpectroData.cHigh = canvas.height
    canvasSpecLine.width = div.offsetWidth - SpectroData.scaleOfsetLeft-20
    canvasSpecLine.height = div.offsetHeight - SpectroData.scaleOfsetBottom-20
    canvasSpecScale.width = div.offsetWidth-20
    canvasSpecScale.height = div.offsetHeight-20

  scaleSpectrogramm()
}

// function to download the spectrum when it is calculated
function downloadSpectrum() {
    var specCanvas = document.getElementById('canvasSpec');
    var scaleCanvas = document.getElementById('canvasSpecScale');
    var scaleContext = scaleCanvas.getContext('2d');
    scaleContext.drawImage(specCanvas, 25, 0);
    var dataURL = scaleCanvas.toDataURL("image/png");
    var link = document.createElement('a');
    link.download = "spectrogram.png";
    link.href = scaleCanvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
    link.click();
}

// Function that scales the spectrogramm canvas to the new set size and copies
// the spectrogram from the temp canvas onto it
function scaleSpectrogramm(){
  var canvas = document.getElementById("canvasSpec")
  var ctx = canvas.getContext("2d")

  // Scaling the canvas to fit the whole temp canvas with the new canvas dimensions
  ctx.scale(SpectroData.cWidth / SpectroData.specWidth, SpectroData.cHigh / SpectroData.specHight);
  SpectroData.scaleFactorWidth = SpectroData.cWidth / SpectroData.specWidth;
  SpectroData.scaleFactorHeight = SpectroData.cHigh / SpectroData.specHight;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(tempCanvas, 0, 0);
  drawScale()
  section = getSectionDisplayed()
  drawSelection(section.min, 2, section.max);
}
    </script>
    <script>var WaveData = {
    gridScale: 1 / 16,
    stepsX: undefined,
    amplitude: undefined,
    rms: undefined,
    scaleX: 1
};

// define global variables for the waveform
var mouseUsed = 0;
var intervalDrawSelect;
var selectionX = NaN;
var startSelection = NaN;
var offSetLeft = 24;
var offSetBottom = 20;
var tempWaveCanvas = document.createElement("canvas");
var tempWaveCtx = tempWaveCanvas.getContext("2d");
var tempRMSCanvas = document.createElement("canvas");
var tempRMSCtx = tempWaveCanvas.getContext("2d");

// function to calculate the waveform and draw it into the canvas
function drawWave() {

    var canvas = document.getElementById("canvasWave");
    var canvasWaveLine = document.getElementById("canvasWaveLine");
    var canvasRMS = document.getElementById("canvasRMS");

    tempWaveCanvas.width = canvas.width;
    tempWaveCanvas.height = canvas.height;
    tempRMSCanvas.width = canvasRMS.width;
    tempRMSCanvas.height = canvasRMS.height;

    canvasWaveLine.addEventListener("mousedown", startPlayHereWave);
    canvasWaveLine.addEventListener("mousedown", waveOnMouseDown);
    canvasWaveLine.addEventListener("mouseup", waveOnMouseUp);
    canvasWaveLine.addEventListener("mousemove", displayWavePosition);
    canvasWaveLine.addEventListener("dblclick", resetSelection);

    if (canvas.getContext) {

        var canvasCtx = canvas.getContext("2d");
        var canvasCtxRMS = canvas.getContext("2d");

        canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
        canvasCtxRMS.clearRect(0, 0, canvasCtx.width, canvasCtx.height);

        var waveScale = 100;
        var canvasBlockLen = Audiodata.signalLen / canvas.width;
        var nPart = Math.floor(Audiodata.signalLen / canvasBlockLen);
        var currentBlock = new Array(canvasBlockLen.length);
        var maxValue = new Array(nPart);
        var minValue = new Array(nPart);
        var peak = new Array(nPart);
        var rms = new Array(nPart);

        // search the min and max samples in on predefined audioblock
        for (i = 0; i < nPart; i++) {

            currentBlock = Audiodata.samples.slice(canvasBlockLen * i, canvasBlockLen * (i + 1));

            maxValue[i] = Math.max(...currentBlock) * waveScale;

            minValue[i] = Math.min(...currentBlock) * waveScale;

            // calculate the RMS of the current sampleblock
            rms[i] = calculateRMS(currentBlock);

            if (Math.max(...currentBlock) >= Math.abs(Math.min(...currentBlock))) {
                peak[i] = Math.max(...currentBlock);
            } else if (Math.max(...currentBlock) < Math.abs(Math.min(...currentBlock))) {
                peak[i] = Math.abs(Math.min(...currentBlock));
            }
        }

        // draw the axes of the waveform
        drawWaveTimeAxes();

        // draw the grid of the waveform
        drawWaveGrid();

        // draw the waveform into the canvas
        tempWaveCtx.beginPath();
        tempWaveCtx.strokeStyle = "#100C87";
        tempWaveCtx.lineWidth = 0.05;

        tempWaveCtx.moveTo(0, canvas.height / 2);
        for (i = 0; i < maxValue.length; i++) {
            tempWaveCtx.lineTo(i, canvas.height / 2 - maxValue[i]);
            tempWaveCtx.lineTo(i, canvas.height / 2 - minValue[i]);
            tempWaveCtx.stroke();
        }

        tempRMSCtx.beginPath();
        tempRMSCtx.strokeStyle = "#66a3ff";
        tempRMSCtx.lineWidth = 0.05;

        tempRMSCtx.moveTo(0, canvas.height / 2);
        for (i = 0; i < maxValue.length; i++) {
            tempRMSCtx.lineTo(i, canvas.height / 2 - rms[i] * waveScale);
            tempRMSCtx.lineTo(i, canvas.height / 2 + rms[i] * waveScale);
            tempRMSCtx.stroke();
        }
        canvasCtxRMS.drawImage(tempRMSCanvas, 0, 0);
        canvasCtx.drawImage(tempWaveCanvas, 0, 0);
        WaveData.amplitude = peak;
        WaveData.rms = rms;
        WaveData.crestFactor = calculateCrestFactor(peak, rms);

    } else {
        // canvas-unsupported code here
        alert("canvas is unsupported on this browser!");
    }

    // calculate the RMS value of the input samples
    function calculateRMS(samples) {

        var sum = 0;

        for (var i = 0; i < samples.length; i++) {
            sum = sum + (samples[i] * samples[i]);
        }

        var rms = Math.sqrt(sum / samples.length);

        return rms;
    }

    // calculate the crest factor using the peak and the rms value
    function calculateCrestFactor(peak, rms) {

        var crestFactor = new Array(rms.length);

        for (var i = 0; i < crestFactor.length; i++) {
            crestFactor[i] = peak[i] / rms[i];
            if (isFinite(crestFactor[i]) == false) {
                crestFactor[i] = 0;
            }
        }
        return crestFactor;
    }

    // set the playback position depending on the current mouse position
    function startPlayHereWave(evt) {

        var mousePos = getMousePos(canvas, evt);
        mouseTime = (Audiodata.signalLen / Audiodata.sampleRate) / canvas.width * mousePos.x;
        if (isPlaying) {
            toggleSound();
        }
        startOffset = mouseTime;
        drawLineKlickWave(mouseTime);
        drawLineKlick(mouseTime);
    }
}

// draw the red playback bar into the waveform
function drawLineKlickWave(mouseTime) {
    var canvasWaveLine = document.getElementById("canvasWaveLine");
    var canvas = document.getElementById("canvasWave");
    var ctxLine = canvasWaveLine.getContext("2d");
    mousePos = (mouseTime * canvas.width) / (Audiodata.signalLen / Audiodata.sampleRate);
    ctxLine.clearRect(0, 0, canvasWaveLine.width, canvasWaveLine.height);
    ctxLine.fillStyle = 'rgb(' + 255 + ',' + 0 + ',' + 0 + ')';
    ctxLine.fillRect(mousePos, 0, 2, canvasWaveLine.height);
    drawLineKlick(mouseTime);
}

// move the red playback bar using requestAnimationFrame()
function drawLinePlayWave() {
    var canvasWaveLine = document.getElementById("canvasWaveLine");
    var ctxLine = canvasWaveLine.getContext("2d");

    if (isPlaying) {
        ctxLine.clearRect(0, 0, canvasWaveLine.width, canvasWaveLine.height);

        ctxLine.fillStyle = 'rgb(' + 255 + ',' + 0 + ',' + 0 + ')';
        ctxLine.fillRect(Math.floor(canvasWaveLine.width / (Audiodata.signalLen / Audiodata.sampleRate) * (audioCtx.currentTime - startTime + startOffset)), 0, 2, canvasWaveLine.height);

        window.requestAnimationFrame(drawLinePlayWave);
    }
}

// draw the axis of the waveform
function drawWaveTimeAxes() {

    var canvasWaveScale = document.getElementById("canvasWaveScale");
    var ctxWaveScale = canvasWaveScale.getContext("2d");
    var canvasWave = document.getElementById('canvasWave');

    var minDistanceNumbersX = 50;
    var maxDistanceNumbersX = 320;

    var trackLenSec = Audiodata.signalLen / Audiodata.sampleRate;

    var logTime = Math.log10(trackLenSec);
    logTime = Math.pow(10, Math.floor(logTime));

    var timePoint = trackLenSec / canvasWave.width;

    WaveData.stepsX = 100;
    var tickNum;

    for (var i = minDistanceNumbersX; i <= maxDistanceNumbersX; i++) {
        var time = timePoint * i;
        var quarter = time % (logTime / 4);
        var half = time % (logTime / 2);
        var full = time % logTime;

        if (quarter <= (timePoint) && (logTime / 4) * Math.ceil(canvasWave.width / i) >= trackLenSec) {
            WaveData.stepsX = i;
            tickNum = (logTime / 4);
            break;
        } else if (half <= (timePoint) && (logTime / 2) * Math.ceil(canvasWave.width / i) >= trackLenSec) {
            WaveData.stepsX = i;
            tickNum = (logTime / 2);
            break;
        } else if (full <= (timePoint) && (logTime) * Math.ceil(canvasWave.width / i) >= trackLenSec) {
            WaveData.stepsX = i;
            tickNum = logTime;
            break;
        }
    }

    ctxWaveScale.clearRect(0, 0, canvasWaveScale.width, canvasWaveScale.height);

    ctxWaveScale.beginPath();
    ctxWaveScale.strokeStyle = "#000000";
    ctxWaveScale.lineWidth = 1;

    ctxWaveScale.moveTo(offSetLeft, 0);
    ctxWaveScale.lineTo(offSetLeft, canvasWaveScale.height - offSetBottom);
    ctxWaveScale.lineTo(canvasWave.width + offSetLeft, canvasWaveScale.height - offSetBottom);
    ctxWaveScale.stroke();

    ctxWaveScale.beginPath();
    ctxWaveScale.lineWidth = 2;
    ctxWaveScale.font = "bold 12px Verdana";

    for (i = 0; i <= canvasWave.width; i += WaveData.stepsX) {
        ctxWaveScale.moveTo(i + offSetLeft, canvasWaveScale.height - offSetBottom);
        ctxWaveScale.lineTo(i + offSetLeft, canvasWaveScale.height - offSetBottom + 5);
        ctxWaveScale.stroke();

        ctxWaveScale.fillText(timeToString((i / WaveData.stepsX) * tickNum, 0, tickNum), i + offSetLeft - 5, canvasWaveScale.height - offSetBottom + 15, offSetLeft - 2);
    }
}

// draw the grid into the waveform
function drawWaveGrid() {

    var canvasWaveGrid = document.getElementById("canvasWaveGrid");
    var ctxWaveGrid = canvasWaveGrid.getContext("2d");

    var gridSize = WaveData.stepsX * WaveData.gridScale;

    var numHorizontal = canvasWaveGrid.height / gridSize;
    var numVertical = canvasWaveGrid.width / gridSize;

    ctxWaveGrid.clearRect(0, 0, canvasWaveGrid.width, canvasWaveGrid.height);

    ctxWaveGrid.beginPath();
    ctxWaveGrid.strokeStyle = "#bfbfbf";
    ctxWaveGrid.lineWidth = 1;

    for (var i = 1; i < numHorizontal; i++) {
        ctxWaveGrid.moveTo(1, gridSize * i);
        ctxWaveGrid.lineTo(canvasWaveGrid.width, gridSize * i);
        ctxWaveGrid.stroke();
    }

    for (var k = 1; k <= numVertical; k++) {
        ctxWaveGrid.moveTo(gridSize * k, 0);
        ctxWaveGrid.lineTo(gridSize * k, canvasWaveGrid.height - 1);
        ctxWaveGrid.stroke();
    }
    ctxWaveGrid.beginPath();
    ctxWaveGrid.strokeStyle = "#000000";
    ctxWaveGrid.lineWidth = 1;
    ctxWaveGrid.moveTo(offSetLeft, canvasWaveGrid.height / 2);
    ctxWaveGrid.lineTo(canvasWaveGrid.width, canvasWaveGrid.height / 2);
    ctxWaveGrid.stroke();
}

// display the current position of the mouse cursor
function displayWavePosition(evt) {

    var canvasWave = document.getElementById("canvasWave");
    var waveTime = document.getElementById("waveTime");

    var mousePos = getMousePos(canvasWave, evt);
    var trackLenSec = Audiodata.signalLen / Audiodata.sampleRate;

    var mouseX = Math.round((trackLenSec / canvasWave.width * mousePos.x) * 100) / 100;
    waveTime.innerHTML = 'Time: ' + timeToString(mouseX, 1, 1);

    var amplitude = WaveData.amplitude[Math.round(mousePos.x / WaveData.scaleX)];
    var rms = WaveData.rms[Math.round(mousePos.x / WaveData.scaleX)];

    if (amplitude == 0) {
        amplitudeValue.innerHTML = 'Amplitude: ' +
            'NaN' +
            ' dB';
    } else {
        amplitude = 20 * Math.log10(amplitude);
        amplitudeValue.innerHTML = 'Amplitude: ' + amplitude.toFixed(1) + ' dB';
    }

    if (rms == 0) {
        rmsValue.innerHTML = 'RMS: ' +
            'NaN' +
            ' dB';
    } else {
        rms = 20 * Math.log10(rms);
        rmsValue.innerHTML = 'RMS: ' + rms.toFixed(1) + ' dB';
    }
}

// define the function for setting the current playback position by pushing down the mouse
// button
function waveOnMouseDown(evt) {
    var canvas = document.getElementById("canvasWave");
    var canvasWaveLine = document.getElementById("canvasWaveLine");
    canvasWaveLine.addEventListener("mousemove", onMouseMove);

    mouseUsed = 1;
    var mousePos = getMousePos(canvas, evt);
    startSelection = mousePos.x;
    intervalDrawSelect = setInterval(function() {
        drawSelection(startSelection, 1, evt);
    }, 30);
}

// function to select a piece of the waveform
function drawSelection(startPos, caller, endPos) {
    var canvas = document.getElementById("canvasWave");
    var canvasSelect = document.getElementById("canvasSelect");
    var ctxSelect = canvasSelect.getContext("2d");

    if (caller == 1 && mouseUsed) {
        var start = startPos;
        var actualPosition = selectionX;
        var widthSelection = (actualPosition - startPos);
        ctxSelect.clearRect(0, 0, canvasSelect.width, canvasSelect.height);
        ctxSelect.fillStyle = 'rgba(' + 255 + ',' + 0 + ',' + 0 + ',' + 0.2 + ')';
        ctxSelect.fillRect(start, 0, widthSelection, canvasSelect.height);
    } else if (caller == 2) {
        var start = (startPos * canvas.width) / (Audiodata.signalLen / Audiodata.sampleRate);
        var actualPosition = (endPos * canvas.width) / (Audiodata.signalLen / Audiodata.sampleRate);
        var widthSelection = (actualPosition - start);
        ctxSelect.clearRect(0, 0, canvasSelect.width, canvasSelect.height);
        ctxSelect.fillStyle = 'rgba(' + 255 + ',' + 0 + ',' + 0 + ',' + 0.2 + ')';
        ctxSelect.fillRect(start, 0, widthSelection, canvasSelect.height);
    }
}

// function for the selection on the waveform by releasing the mouse button
function waveOnMouseUp(evt) {
    canvasWaveLine = document.getElementById("canvasWaveLine");
    var canvas = document.getElementById("canvasWave");
    mousePos = getMousePos(canvasWaveLine, evt);
    mousePos = mousePos.x;
    mouseUsed = 0;
    SpectroData.endTimeSelection = (Audiodata.signalLen / Audiodata.sampleRate) / canvas.width * mousePos;

    if (selectionX < startSelection) {
        drawLineKlickWave(SpectroData.endTimeSelection);
        startOffset = SpectroData.endTimeSelection;
        SpectroData.endTimeSelection = mousePos;
    }
    canvasWaveLine.removeEventListener("mousemove", onMouseMove);
    clearInterval(intervalDrawSelect);
    zoomToSelection((Audiodata.signalLen / Audiodata.sampleRate) / canvas.width * startSelection, (Audiodata.signalLen / Audiodata.sampleRate) / canvas.width * mousePos);
    startSelection = NaN;
    selectionX = NaN;
}

// function for the current mouse position
function onMouseMove(evt) {
    canvasWaveLine = document.getElementById("canvasWaveLine");
    mousePos = getMousePos(canvasWaveLine, evt);
    selectionX = mousePos.x;
}

// function to select the hole waveform by double clicking the mouse button
function resetSelection() {
    var canvasSelect = document.getElementById("canvasSelect");
    var ctxSelect = canvasSelect.getContext("2d");
    SpectroData.endTimeSelection = NaN;
    ctxSelect.clearRect(0, 0, canvasSelect.width, canvasSelect.height);
    scaleFullSpec();
}
</script>
    <script>
        var grayScale;

// write rgb data into colorscale
function createGray() {
    var rgbR = [0.0000, 2.5758, 5.1515, 7.7273, 10.3030, 12.8788, 15.4545, 18.0303, 20.6061, 23.1818, 25.7576, 28.3333, 30.9091, 33.4848, 36.0606, 38.6364, 41.2121, 43.7879, 46.3636, 48.9394, 51.5152, 54.0909, 56.6667, 59.2424, 61.8182, 64.3939, 66.9697, 69.5455, 72.1212, 74.6970, 77.2727, 79.8485, 82.4242, 85.0000, 87.5758, 90.1515, 92.7273, 95.3030, 97.8788, 100.4545, 103.0303, 105.6061, 108.1818, 110.7576, 113.3333, 115.9091, 118.4848, 121.0606, 123.6364, 126.2121, 128.7879, 131.3636, 133.9394, 136.5152, 139.0909, 141.6667, 144.2424, 146.8182, 149.3939, 151.9697, 154.5455, 157.1212, 159.6970, 162.2727, 164.8485, 167.4242, 170.0000, 172.5758, 175.1515, 177.7273, 180.3030, 182.8788, 185.4545, 188.0303, 190.6061, 193.1818, 195.7576, 198.3333, 200.9091, 203.4848, 206.0606, 208.6364, 211.2121, 213.7879, 216.3636, 218.9394, 221.5152, 224.0909, 226.6667, 229.2424, 231.8182, 234.3939, 236.9697, 239.5455, 242.1212, 244.6970, 247.2727, 249.8485, 252.4242, 255.0000, ];

    var rgbG = [0.0000, 2.5758, 5.1515, 7.7273, 10.3030, 12.8788, 15.4545, 18.0303, 20.6061, 23.1818, 25.7576, 28.3333, 30.9091, 33.4848, 36.0606, 38.6364, 41.2121, 43.7879, 46.3636, 48.9394, 51.5152, 54.0909, 56.6667, 59.2424, 61.8182, 64.3939, 66.9697, 69.5455, 72.1212, 74.6970, 77.2727, 79.8485, 82.4242, 85.0000, 87.5758, 90.1515, 92.7273, 95.3030, 97.8788, 100.4545, 103.0303, 105.6061, 108.1818, 110.7576, 113.3333, 115.9091, 118.4848, 121.0606, 123.6364, 126.2121, 128.7879, 131.3636, 133.9394, 136.5152, 139.0909, 141.6667, 144.2424, 146.8182, 149.3939, 151.9697, 154.5455, 157.1212, 159.6970, 162.2727, 164.8485, 167.4242, 170.0000, 172.5758, 175.1515, 177.7273, 180.3030, 182.8788, 185.4545, 188.0303, 190.6061, 193.1818, 195.7576, 198.3333, 200.9091, 203.4848, 206.0606, 208.6364, 211.2121, 213.7879, 216.3636, 218.9394, 221.5152, 224.0909, 226.6667, 229.2424, 231.8182, 234.3939, 236.9697, 239.5455, 242.1212, 244.6970, 247.2727, 249.8485, 252.4242, 255.0000, ];

    var rgbB = [0.0000, 2.5758, 5.1515, 7.7273, 10.3030, 12.8788, 15.4545, 18.0303, 20.6061, 23.1818, 25.7576, 28.3333, 30.9091, 33.4848, 36.0606, 38.6364, 41.2121, 43.7879, 46.3636, 48.9394, 51.5152, 54.0909, 56.6667, 59.2424, 61.8182, 64.3939, 66.9697, 69.5455, 72.1212, 74.6970, 77.2727, 79.8485, 82.4242, 85.0000, 87.5758, 90.1515, 92.7273, 95.3030, 97.8788, 100.4545, 103.0303, 105.6061, 108.1818, 110.7576, 113.3333, 115.9091, 118.4848, 121.0606, 123.6364, 126.2121, 128.7879, 131.3636, 133.9394, 136.5152, 139.0909, 141.6667, 144.2424, 146.8182, 149.3939, 151.9697, 154.5455, 157.1212, 159.6970, 162.2727, 164.8485, 167.4242, 170.0000, 172.5758, 175.1515, 177.7273, 180.3030, 182.8788, 185.4545, 188.0303, 190.6061, 193.1818, 195.7576, 198.3333, 200.9091, 203.4848, 206.0606, 208.6364, 211.2121, 213.7879, 216.3636, 218.9394, 221.5152, 224.0909, 226.6667, 229.2424, 231.8182, 234.3939, 236.9697, 239.5455, 242.1212, 244.6970, 247.2727, 249.8485, 252.4242, 255.0000, ];

    grayScale = [rgbR, rgbG, rgbB];
}

    </script>
    <script>
        var jetScale;

// write rgb data into colorscale
function createJet() {
    var rgbR = [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 10.2000, 20.4000, 30.6000, 40.8000, 51.0000, 61.2000, 71.4000, 81.6000, 91.8000, 102.0000, 112.2000, 122.4000, 132.6000, 142.8000, 153.0000, 163.2000, 173.4000, 183.6000, 193.8000, 204.0000, 214.2000, 224.4000, 234.6000, 244.8000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 244.8000, 234.6000, 224.4000, 214.2000, 204.0000, 193.8000, 183.6000, 173.4000, 163.2000, 153.0000, 142.8000, 132.6000, ];

    var rgbG = [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 10.2000, 20.4000, 30.6000, 40.8000, 51.0000, 61.2000, 71.4000, 81.6000, 91.8000, 102.0000, 112.2000, 122.4000, 132.6000, 142.8000, 153.0000, 163.2000, 173.4000, 183.6000, 193.8000, 204.0000, 214.2000, 224.4000, 234.6000, 244.8000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 244.8000, 234.6000, 224.4000, 214.2000, 204.0000, 193.8000, 183.6000, 173.4000, 163.2000, 153.0000, 142.8000, 132.6000, 122.4000, 112.2000, 102.0000, 91.8000, 81.6000, 71.4000, 61.2000, 51.0000, 40.8000, 30.6000, 20.4000, 10.2000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, ];

    var rgbB = [132.6000, 142.8000, 153.0000, 163.2000, 173.4000, 183.6000, 193.8000, 204.0000, 214.2000, 224.4000, 234.6000, 244.8000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 255.0000, 244.8000, 234.6000, 224.4000, 214.2000, 204.0000, 193.8000, 183.6000, 173.4000, 163.2000, 153.0000, 142.8000, 132.6000, 122.4000, 112.2000, 102.0000, 91.8000, 81.6000, 71.4000, 61.2000, 51.0000, 40.8000, 30.6000, 20.4000, 10.2000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, ];

    jetScale = [rgbR, rgbG, rgbB];
}

    </script>
    <script>
        var hsvScale;

// write rgb data into colorscale
function createHsv() {
      var rgbR = [243.7510,235.7528,228.0571,220.4665,212.7668,204.8790,196.8328,188.6960,180.5650,172.5476,164.7490,157.2520,150.1121,143.3621,137.0244,131.1130,125.6422,120.6273,116.0833,112.0232,108.4554,105.3819,102.7902,100.6590,98.9549,97.6338,96.6429,95.9237,95.4127,95.0450,94.7571,94.4861,94.1706,93.7490,93.1581,92.3327,91.2031,89.6931,87.7232,85.2195,82.1299,78.4493,74.2313,69.5669,64.5568,59.2900,53.8317,48.2270,42.5012,36.6650,36.9777,43.5439,50.1465,56.7923,63.4869,70.2280,77.0135,83.8325,90.6709,97.5052,104.3036,111.0248,117.6184,124.0333,130.2214,136.1473,141.7913,147.1468,152.2200,157.0202,161.5577,165.8411,169.8768,173.6681,177.2167,180.5235,183.5882,186.4111,188.9940,191.3420,193.4639,195.3774,197.1078,198.6896,200.1674,201.5942,203.0310,204.5416,206.1895,208.0332,210.1227,212.4959,215.1769,218.1685,221.4404,224.9347,228.7649,233.2687,238.3407,243.7510,];

      var rgbG = [234.5007,229.9344,225.3192,220.7200,216.2161,211.8353,207.5571,203.3432,199.1476,194.9267,190.6463,186.2853,181.8348,177.2934,172.6622,167.9435,163.1385,158.2468,153.2671,148.1976,143.0359,137.7795,132.4273,126.9780,121.4314,115.7880,110.0489,104.2157,98.2913,92.2796,86.1861,80.0186,73.7893,67.5172,61.2320,54.9809,48.8360,42.9042,37.3323,32.2957,27.9551,24.3806,21.4976,19.1249,17.0503,15.0872,13.1065,11.0142,8.7958,6.6627,6.7859,9.1646,11.5789,13.7799,15.7846,17.6328,19.3593,21.0094,22.6352,24.3044,26.0982,28.1094,30.4327,33.1456,36.2952,39.8873,43.8924,48.2610,52.9344,57.8611,62.9993,68.3171,73.7911,79.4042,85.1438,90.9992,96.9615,103.0219,109.1706,115.3965,121.6860,128.0227,134.3876,140.7599,147.1171,153.4370,159.6986,165.8842,171.9811,177.9820,183.8855,189.6962,195.4249,201.0905,206.7261,212.3840,218.0636,223.6322,229.0858,234.5007,];

      var rgbB = [244.3209,237.9423,231.9950,226.5918,221.7205,217.3138,213.3494,209.8475,206.8260,204.2728,202.1419,200.3661,198.8738,197.6021,196.5004,195.5263,194.6453,193.8265,193.0411,192.2600,191.4543,190.5938,189.6487,188.5886,187.3837,186.0043,184.4215,182.6056,180.5277,178.1584,175.4655,172.4135,168.9621,165.0649,160.6648,155.7038,150.1162,143.8405,136.8349,129.1061,120.7400,111.9160,102.8705,93.8227,84.9295,76.2830,67.9113,59.8176,51.9753,44.3535,42.9251,47.4255,51.7386,55.8498,59.7395,63.3857,66.7591,69.8267,72.5503,74.8910,76.8113,78.2866,79.3171,79.9298,80.1875,80.1786,80.0035,79.7593,79.5314,79.3892,79.3897,79.5813,80.0071,80.7086,81.7273,83.1038,84.8810,87.1027,89.8121,93.0506,96.8580,101.2619,106.2808,111.9200,118.1691,125.0007,132.3709,140.2232,148.4857,157.0834,165.9400,174.9824,184.1403,193.3502,202.5358,211.5345,219.9962,227.9646,235.9940,244.3209,];

      hsvScale = [rgbR, rgbG, rgbB];
}
</script>
    <script>
        var twilightScale;
var sunlightScale;

// write rgb data into colorscale
function createTwilight() {
      var rgbR=[243.7510,235.7528,228.0571,220.4665,212.7668,204.8790,196.8328,188.6960,180.5650,172.5476,164.7490,157.2520,150.1121,143.3621,137.0244,131.1130,125.6422,120.6273,116.0833,112.0232,108.4554,105.3819,102.7902,100.6590,98.9549,97.6338,96.6429,95.9237,95.4127,95.0450,94.7571,94.4861,94.1706,93.7490,93.1581,92.3327,91.2031,89.6931,87.7232,85.2195,82.1299,78.4493,74.2313,69.5669,64.5568,59.2900,53.8317,48.2270,42.5012,36.6650,36.9777,43.5439,50.1465,56.7923,63.4869,70.2280,77.0135,83.8325,90.6709,97.5052,104.3036,111.0248,117.6184,124.0333,130.2214,136.1473,141.7913,147.1468,152.2200,157.0202,161.5577,165.8411,169.8768,173.6681,177.2167,180.5235,183.5882,186.4111,188.9940,191.3420,193.4639,195.3774,197.1078,198.6896,200.1674,201.5942,203.0310,204.5416,206.1895,208.0332,210.1227,212.4959,215.1769,218.1685,221.4404,224.9347,228.7649,233.2687,238.3407,243.7510,];

      var rgbG=[234.5007,229.9344,225.3192,220.7200,216.2161,211.8353,207.5571,203.3432,199.1476,194.9267,190.6463,186.2853,181.8348,177.2934,172.6622,167.9435,163.1385,158.2468,153.2671,148.1976,143.0359,137.7795,132.4273,126.9780,121.4314,115.7880,110.0489,104.2157,98.2913,92.2796,86.1861,80.0186,73.7893,67.5172,61.2320,54.9809,48.8360,42.9042,37.3323,32.2957,27.9551,24.3806,21.4976,19.1249,17.0503,15.0872,13.1065,11.0142,8.7958,6.6627,6.7859,9.1646,11.5789,13.7799,15.7846,17.6328,19.3593,21.0094,22.6352,24.3044,26.0982,28.1094,30.4327,33.1456,36.2952,39.8873,43.8924,48.2610,52.9344,57.8611,62.9993,68.3171,73.7911,79.4042,85.1438,90.9992,96.9615,103.0219,109.1706,115.3965,121.6860,128.0227,134.3876,140.7599,147.1171,153.4370,159.6986,165.8842,171.9811,177.9820,183.8855,189.6962,195.4249,201.0905,206.7261,212.3840,218.0636,223.6322,229.0858,234.5007,];

      var rgbB=[244.3209,237.9423,231.9950,226.5918,221.7205,217.3138,213.3494,209.8475,206.8260,204.2728,202.1419,200.3661,198.8738,197.6021,196.5004,195.5263,194.6453,193.8265,193.0411,192.2600,191.4543,190.5938,189.6487,188.5886,187.3837,186.0043,184.4215,182.6056,180.5277,178.1584,175.4655,172.4135,168.9621,165.0649,160.6648,155.7038,150.1162,143.8405,136.8349,129.1061,120.7400,111.9160,102.8705,93.8227,84.9295,76.2830,67.9113,59.8176,51.9753,44.3535,42.9251,47.4255,51.7386,55.8498,59.7395,63.3857,66.7591,69.8267,72.5503,74.8910,76.8113,78.2866,79.3171,79.9298,80.1875,80.1786,80.0035,79.7593,79.5314,79.3892,79.3897,79.5813,80.0071,80.7086,81.7273,83.1038,84.8810,87.1027,89.8121,93.0506,96.8580,101.2619,106.2808,111.9200,118.1691,125.0007,132.3709,140.2232,148.4857,157.0834,165.9400,174.9824,184.1403,193.3502,202.5358,211.5345,219.9962,227.9646,235.9940,244.3209,];

      twilightScale = [rgbR, rgbG, rgbB];

      // flip twilight colorscale
      var rgbRshift = new Array(rgbR.length);
      var rgbGshift = new Array(rgbG.length);
      var rgbBshift = new Array(rgbB.length);

      var halfColorScale = rgbRshift.length / 2;

      for (var i = 0; i < halfColorScale; i++) {
          rgbRshift[i] = rgbR[halfColorScale + i];
          rgbGshift[i] = rgbG[halfColorScale + i];
          rgbBshift[i] = rgbB[halfColorScale + i];
          rgbRshift[i + halfColorScale] = rgbR[i];
          rgbGshift[i + halfColorScale] = rgbG[i];
          rgbBshift[i + halfColorScale] = rgbB[i];
      }
      sunlightScale = [rgbRshift, rgbGshift, rgbBshift];
}

    </script>
    <script>
        var viridisScale;

// write rgb data into colorscale
function createViridis(){
      var rgbR = [70.1250,70.1250,70.1250,70.1250,70.1250,69.6150,69.1050,68.5950,68.0850,67.3200,66.5550,65.7900,65.0250,63.2400,61.4550,59.6700,57.8850,55.3988,52.9125,50.4263,47.9400,43.2225,38.5050,33.7875,29.0700,21.8025,14.5350,7.2675,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,16.2563,32.5125,48.7688,65.0250,74.0138,83.0025,91.9913,100.9800,108.5025,116.0250,123.5475,131.0700,137.8275,144.5850,151.3425,158.1000,164.6025,171.1050,177.6075,184.1100,190.1025,196.0950,202.0875,208.0800,213.8175,219.5550,225.2925,231.0300,236.5125,241.9950,247.4775,252.9600,];

      var rgbG = [2.0400,7.5225,13.0050,18.4875,23.9700,27.7312,31.4925,35.2537,39.0150,42.5213,46.0275,49.5337,53.0400,56.2912,59.5425,62.7937,66.0450,69.0412,72.0375,75.0337,78.0300,81.2813,84.5325,87.7837,91.0350,94.0313,97.0275,100.0237,103.0200,106.0163,109.0125,112.0088,115.0050,118.0013,120.9975,123.9938,126.9900,129.7313,132.4725,135.2138,137.9550,140.6962,143.4375,146.1788,148.9200,151.4700,154.0200,156.5700,159.1200,161.6063,164.0925,166.5787,169.0650,171.2963,173.5275,175.7587,177.9900,180.2213,182.4525,184.6838,186.9150,188.9550,190.9950,193.0350,195.0750,196.7962,198.5175,200.2388,201.9600,203.7450,205.5300,207.3150,209.1000,210.5663,212.0325,213.4987,214.9650,215.9850,217.0050,218.0250,219.0450,220.0650,221.0850,222.1050,223.1250,223.8263,224.5275,225.2288,225.9300,226.4400,226.9500,227.4600,227.9700,227.7150,227.4600,227.2050,226.9500,];

      var rgbB = [78.0300,80.7712,83.5125,86.2537,88.9950,91.7362,94.4775,97.2188,99.9600,102.4462,104.9325,107.4188,109.9050,112.2000,114.4950,116.7900,119.0850,121.3163,123.5475,125.7788,128.0100,129.9863,131.9625,133.9388,135.9150,137.4450,138.9750,140.5050,142.0350,143.2463,144.4575,145.6688,146.8800,147.9000,148.9200,149.9400,150.9600,151.4700,151.9800,152.4900,153.0000,153.2550,153.5100,153.7650,154.0200,153.7650,153.5100,153.2550,153.0000,152.4900,151.9800,151.4700,150.9600,149.9400,148.9200,147.9000,146.8800,145.6688,144.4575,143.2463,142.0350,140.2500,138.4650,136.6800,134.8950,132.6638,130.4325,128.2013,125.9700,123.4838,120.9975,118.5113,116.0250,113.2838,110.5425,107.8013,105.0600,102.0638,99.0675,96.0712,93.0750,90.0787,87.0825,84.0862,81.0900,78.0938,75.0975,72.1013,69.1050,66.8100,64.5150,62.2200,59.9250,57.6938,55.4625,53.2312,51.0000,];

      viridisScale = [rgbR, rgbG, rgbB];
}

    </script>
    <script>var plasmaScale;

// write rgb data into colorscale
function createPlasma(){
      var rgbR = [0.0000,9.4987,18.9975,28.4962,37.9950,46.4737,54.9525,63.4312,71.9100,77.7112,83.5125,89.3137,95.1150,99.8325,104.5500,109.2675,113.9850,118.0013,122.0175,126.0338,130.0500,133.8113,137.5725,141.3337,145.0950,148.3463,151.5975,154.8488,158.1000,161.3512,164.6025,167.8537,171.1050,173.8463,176.5875,179.3287,182.0700,184.5563,187.0425,189.5288,192.0150,194.5013,196.9875,199.4738,201.9600,204.0000,206.0400,208.0800,210.1200,211.8412,213.5625,215.2838,217.0050,218.5350,220.0650,221.5950,223.1250,224.3363,225.5475,226.7588,227.9700,228.9900,230.0100,231.0300,232.0500,232.8150,233.5800,234.3450,235.1100,235.5563,236.0025,236.4488,236.8950,236.8950,236.8950,236.8950,236.8950,236.6400,236.3850,236.1300,235.8750,235.1738,234.4725,233.7712,233.0700,232.0500,231.0300,230.0100,228.9900,227.5238,226.0575,224.5913,223.1250,221.8500,220.5750,219.3000,218.0250];

      var rgbG = [23.9700,21.4837,18.9975,16.5113,14.0250,11.0287,8.0325,5.0362,2.0400,1.5300,1.0200,0.5100,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.2550,0.5100,0.7650,1.0200,5.7375,10.4550,15.1725,19.8900,23.9063,27.9225,31.9387,35.9550,39.4613,42.9675,46.4737,49.9800,53.4862,56.9925,60.4988,64.0050,67.5112,71.0175,74.5238,78.0300,81.2813,84.5325,87.7837,91.0350,94.5412,98.0475,101.5537,105.0600,108.5663,112.0725,115.5788,119.0850,122.5913,126.0975,129.6038,133.1100,136.8075,140.5050,144.2025,147.9000,151.4063,154.9125,158.4187,161.9250,165.6863,169.4475,173.2087,176.9700,180.7312,184.4925,188.2538,192.0150,195.7762,199.5375,203.2988,207.0600,210.8213,214.5825,218.3438,222.1050,226.0575,230.0100,233.9625,237.9150,242.1863,246.4575,250.7287,255.0000];

      var rgbB = [136.9350,136.9350,136.9350,136.9350,136.9350,137.1900,137.4450,137.7000,137.9550,138.4650,138.9750,139.4850,139.9950,140.2500,140.5050,140.7600,141.0150,141.0150,141.0150,141.0150,141.0150,141.0150,141.0150,141.0150,141.0150,140.5050,139.9950,139.4850,138.9750,138.2100,137.4450,136.6800,135.9150,135.2138,134.5125,133.8113,133.1100,131.5800,130.0500,128.5200,126.9900,125.5237,124.0575,122.5913,121.1250,119.0850,117.0450,115.0050,112.9650,110.4788,107.9925,105.5063,103.0200,100.0237,97.0275,94.0313,91.0350,87.5288,84.0225,80.5162,77.0100,72.2288,67.4475,62.6663,57.8850,51.1912,44.4975,37.8038,31.1100,23.3325,15.5550,7.7775,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,3.7613,7.5225,11.2838,15.0450,29.0063,42.9675,56.9288,70.8900];

      plasmaScale = [rgbR, rgbG, rgbB];
}
</script>


    <!-- Create a canvas for the spectrum or for the other display types -->
    <div class="canvas" id="canvasDivSpec">
        <canvas id="canvasSpec" width="1176" height="512"></canvas>
        <canvas id="canvasSpecScale" width="1200" height="540"></canvas>
        <canvas id="canvasSpecLine" width="1176" height="512"></canvas>
    </div>
    <div class="specButtonsY">
        <button id="plusY">+</button>
        <button id="minusY">-</button>
    </div>
    <div class="specButtonsX">
        <button id="minusX">-</button>
        <button id="plusX">+</button>
    </div>
    <div id="divSpecPosition">
        <p id="specTime">Time:</p>
        <p id="specFreq">Freq:</p>
        <p id="magnitute">Value:</p>
    </div>

    <!-- Create a button for saving the spectrum as .png format -->
    <div class="range-container">
        <button id="saveSpec" type="button" onclick="downloadSpectrum()" disabled>Save</button>
        <span class="tooltiptext">Save a picture of the information displayed above</span>
    </div>

</body>